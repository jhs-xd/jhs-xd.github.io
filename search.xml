<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[换电脑后]]></title>
    <url>%2F2019%2F08%2F29%2F%E6%8D%A2%E7%94%B5%E8%84%91%E5%90%8E%2F</url>
    <content type="text"><![CDATA[若不抽出时间来创造自己想要的生活，你最终将不得不花费大量的时间来应付自己不想要的生活. 换电脑带来的问题 博客Post时间和博客顺序无法还原 由于是通过拷贝的方式备份的原来的Blog文件夹，在新电脑上安装完hexo和node.js等环境后， hexo g ——&gt; hexo d 重新推送之前的博客内容后，系统判断每一篇博客的Post时间都是当前时间，所以博客的顺序就是随机的，即无法还原之前正确的博客顺序。 少备份了两篇博客 备份时间不是最后一次推送之后，少备份了两篇，于是照着服务端的博客样式把漏掉的两篇重新敲了一遍，浪费了较长时间。 换电脑后继续写hexo博客的方法方法一：源文件拷贝容易想到，但弊端明显，如上所述。具体操作步骤可参考这篇博文，我就照着这个操作的，不建议这个方法。 方法二：GitHub管理（推荐） 解决方案：在github上已经生成的hexo静态代码处建立另一个分支，利用这个分支来管理自己hexo的源文件 操作步骤：参考这篇博文。]]></content>
      <categories>
        <category>hello hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于VirtualBox虚拟机安装Ubuntu]]></title>
    <url>%2F2019%2F08%2F29%2F%E5%9F%BA%E4%BA%8EVirtualBox%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85Ubuntu%2F</url>
    <content type="text"><![CDATA[静坐常思己过，闲谈莫论人生. 安装VirtualBox VirtualBox官网下载安装之，默认设置即可 运行VirtualBox,Ctrl+G打开全局设定，自行设置默认虚拟电脑位置、语言等选项 同样在官网下载安装VirtualBox扩展包，在全局设定的“扩展”选项中添加扩展包，扩展包名称为Oracle VM VirtualBox Extension Pack 扩展包用于支持USB 2.0和USB 3.0设备，VirtualBox RDP，磁盘加密，NVMe和PXE启动英特尔卡 一般安装的扩展包版本应该与VirtualBox版本相同 安装Ubuntu创建虚拟机 运行VirtualBox，新建一个虚拟机 虚拟机名称随意 操作系统类型选择Linux 版本选择Ubuntu（64-bit） 设置内存大小 此内存为虚拟机所占的系统内存 一般设置不超过主机系统内存的1/2 创建虚拟硬盘 按照提示选择“现在创建虚拟硬盘” 虚拟硬盘文件类型选择为默认的“VDI(VirtualBox 磁盘映像)” 选择“动态分配”的虚拟硬盘分配方式 设置虚拟硬盘文件的名称、位置和虚拟硬盘的大小 点击“创建”即创建了一台虚拟机，相当于一个没有安装操作系统的电脑主机 在虚拟机上安装Ubuntu操作系统 Ubuntu官网下载桌面版系统“Ubuntu Desktop”，点击ReleaseNotes，选择Ubuntu Desktop and Server类型的版本，当前最新版本为Ubuntu 18.04.2 LTS 在VirtualBox中启动创建好的虚拟机，弹出“选择启动盘”对话框，选择下载好的虚拟光盘ubuntu-18.04.2-desktop-amd64.iso，点击“启动”即可进入操作系统安装界面 按照提示设置安装Ubuntu，可能持续几十分钟 安装完毕后，重启Ubuntu 安装VirtualBox增强功能安装VirtualBox增强功能可以实现：共享文件夹、粘贴板以及鼠标无缝移动等。安装步骤： - 进入Ubuntu操作系统，在上方“设备”选项卡中选择“安装增强功能”，此时桌面出现一个光盘图标 - Ctrl+Alt+T打开终端，逐步输入如下命令 - cd /media/ - ls - cd 上面一行的内容（是你设置的虚拟硬盘的名称） - ls - cd 上面一行的内容（VBOXADDITIONS_版本号） - ls - sudo ./VBoxLinuxAddionions.run - 按照提示输入安装Ubuntu系统时设置的密码回车即可（密码输入是隐式的） 配置Ubuntu设置服务器镜像源目的：将默认的服务器更改为获取资源最快的国内服务器 - 打开“软件和更新” - 选择下载服务器 - 选择最佳服务器，授权 - 关闭“软件和更新”，重新载入可用软件包列表 apt终端命令apt（Advanced Packaging Tool）是Ubuntu的安装包管理工具。 更新可用软件包列表 sudo apt-get update 更新已安装的包 sudo apt-get upgrade 安装软件 sudo apt install XXX 安装Google浏览器： - 从https://www.google.com/chrome/?platform=linux下载安装文件 - sudo apt install libappindicator1 libindicator7 - sudo dpkg -i XXX.deb - sudo apt -f install 安装搜狗输入法： - 在系统设置的语言支持中将“键盘输入法系统”修改为fcitx - 访问http://pinyin.sougou.com/linux/下载安装文件 - 在终端输入 sudo dpkg -i XXX.deb; sudo apt -f install 卸载软件 sudo apt remove XXX 查找软件 apt-cache search XXX deb格式的安装包deb是Debian Linux的安装格式，在Ubuntu中同样可以使用。 sudo dpkg -i XXX.deb]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>VirtualBox</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux操作系统]]></title>
    <url>%2F2019%2F08%2F29%2FLinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[Variety is the spice of life. 什么是操作系统 操作系统是计算机硬件与用户之间沟通的纽带 没有安装操作系统的计算机被称为裸机 在裸机上只能用机器语言编写程序 计算机安装操作系统后，就可以在操作系统上安装支持的高级语言环境，使用高级语言开发程序 操作系统的作用 直接操作计算机硬件 把操作硬件的代码封装为系统调用，以供应用软件的开发 操作系统分类根据应用领域的不同，主流操作系统可分为以下四类： 桌面操作系统 服务器操作系统 嵌入式操作系统 移动设备操作系统 桌面操作系统 Windows 用户群体大 应用软件多 安全性、稳定性较差 macOS 基于Unix 更安全、稳定 适合开发人员 Linux 应用软件少 用户群体小 服务器操作系统服务器的维护：通过SSH客户端软件登录服务器实现远程维护 Linux 安全、稳定、免费 配套服务器软件更齐全 占有率高 Windows Server 付费 占有率低 嵌入式操作系统嵌入式开发：智能硬件开发 Linux 开源、免费 内核小 开发商可自行定制 移动设别操作系统移动设备：智能手机、平板（也属于嵌入式系统） iOS Android（基于Linux） 虚拟机虚拟机指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。 - 虚拟系统通过生成现有操作系统的全新虚拟镜像，具有与真实操作系统完全相同的功能 - 进入虚拟系统后，所有操作都是在这个全新的独立的虚拟系统中进行，可以独立安装运行软件、保存数据，不会对真实的操作系统产生任何影响 - 可以真实操作系统和虚拟系统之间的灵活切换 通过在虚拟机中安装各种操作系统和软件，可以安全、方便地学习新的操作系统和软件。 Linux内核及发行版本 Linux内核版本内核程序是系统的心脏，用来管理硬件设备、提供系统调用，在硬件和应用程序之间提供了一个抽象层。 Linux内核版本中调用关系：终端命令——&gt;系统调用——&gt;硬件设备 Linux发行版本 （1）Linux发行版本中除了Linux内核，通常包含了： 桌面环境 办公套件 媒体播放器 数据库等应用软件 （2）常见的Linux发行版本： Ubuntu Redhat Fedora Debian openSUSE CentOS Linux Mint Manjaro Mageia Arch 常用Linux终端命令学习Linux终端命令的原因 Linux刚面世的时候没有图形界面，所有操作全靠终端命令完成，如磁盘操作、文件存取、进程管理等 服务器维护都是通过SSH客户端远程实现，而SSH客户端没有图形界面 Linux发行版本的终端命令有200余个，但是常用的仅10多个 常用Linux终端命令 终端快捷键： 打开终端：Ctrl+Alt+T 增大字号：Ctrl+Shift+= 减小字号：Ctrl+- Tab ：自动补全（按两下，提示可能存在的命令） 7个常用命令： 序号 命令 对应英文 作用 1 ls list 查看当前文件夹下的内容 ls -a 显示指定目录下所有子目录与文件，包括隐藏文件 ls -l 以列表的方式显示文件的详细信息 ls -lh 以人性化的方式显示文件大小 2 cd [目录名] change directory 切换文件夹 cd 回到当前账户的主目录（/home/用户目录） cd ~ 回到当前账户的主目录 cd . 保持当前目录 cd .. 切换到上级目录 cd - 在最近两次工作目录之间来回切换 3 pwd print work directory 查看当前文件夹 4 mkdir [目录名] make directory 创建文件夹 mkdir -p [递归目录] 可以递归创建目录 5 touch [文件名] touch 如果文件不存在，新建文件；如果文件存在，更新文件的末次修改日期 6 rm[文件名] remove 删除指定名称的文件（删除后不可恢复） rm -r [文件夹名] 删除指定名称的文件夹 rm -f [文件名] 强制删除，忽略不存在的文件 7 clear clear 清屏 查阅终端命令的帮助信息： 方式一：command --help ：查看帮助信息 方式二：man command ：查阅详细手册 - 按 Enter ：一行行显示 - 按 Space/f ：下一屏 - 按 b ：上一屏 - 按 q ：退出 Linux下文件和目录的特点： - Linux文件或目录名称最长可以有256个字符 - 以 . 开头的文件为隐藏文件，需要用 -a 参数才能显示 - . 代表当前目录 - .. 代表上一级目录 - 相对路径：输入路径时，最前面不是 / 或者 ~ ，表示相对当前目录的目录位置 - 绝对路径：输入路径时，最前面是 / 或者 ~ ，表示从根目录或家目录开始的具体目录位置 其他终端命令： 1 tree [目录名] 以树状图列出文件目录结构 tree -d 只显示目录 2 cp 源文件 目标文件 复制文件或目录 cp -f 强制复制，已经存在的目标文件直接覆盖，不提示 cp -i 覆盖文件前提示 cp -r 复制文件夹，若给出的源文件是目录文件才执行cp，将递归复制该目录下的所有子目录和文件，目标文件必须是一个目录名 3 mv 源文件 目标文件 移动文件或目录/文件或目录重命名 mv -i 覆盖文件前提示 4 cat [文件名] 查看文件内容、创建文件、文件合并、追加文件内容等 cat -b 对非空输出行编号（与 nl 命令等价） cat -n 对输出的所有行编号 5 more [文件名] 分屏显示文件内容 * cat 与 more 的区别： cat 一次显示所有内容，适合查看内容较少的文本文件 6 grep “搜索文本文件内容” 搜索文本文件名 grep -n 显示匹配行及行号 grep -v 显示不包含匹配文本的所有行（求反） grep -i 忽略大小写 * 常用的两种模式的查找： ^a ：行首，查找以 a 开头的行 ke$ ：行尾，查找以 ke 结束的行 7 echo 文字内容 在终端中显示参数指定的文字，通常和重定向联合使用 * 重定向之 &gt; 和 &gt;&gt; 的区别： &gt; 表示输出，会覆盖原有文件的内容 &gt;&gt; 表示追加，会将内容追加到已有文件内容的末尾 * echo 与 touch 的区别： echo 在创建文件的同时，也指定的文件的内容（echo hello &gt; a.txt） touch 只能创建一个空的文件 8 管道 | - Linux 允许将一个命令的输出通过 管道 作为另一个命令的输入 - 命令1（写） | 命令2（读） - 常用的管道命令有： more：分屏显示内容 grep：在命令执行结果的基础上查询指定的文本 远程管理常用命令 1 关机 shutdown 时间（now：立刻关机；不指定时间，默认1分钟后关机；20:30：八点半关机；+10:10分钟后关机） 取消关机 shutdown -c 重启 shutdown -r 时间 2 查看或配置网卡信息 ifconfig * 查看网卡对应的IP地址 ifconfig | grep inet * 127.0.0.1 被称为本地回环地址，一般用来测试本机网卡是否正常 3 检测到目标IP地址的连接是否正常 ping 4 远程登录和复制文件 * 远程登录 ssh [-p 端口号] 用户名@IP * 远程复制文件 scp [-P（大写） 端口号] [-r] 用户名@IP:文件名或路径 用户名@IP:文件名或路径 SSH基础 （1）在Linux中SSH是非常常用的工具，通过SSH客户端可以连接到运行了SSH服务端的远程机器上。 - SSH客户端是一种使用 Secure Shell（SSH）协议连接到远程计算机的软件程序 - SSH目前比较可靠，专为远程登录会话和其他网络服务提供安全性的协议 - 利用SSH协议可以有效防止远程管理过程中的信息泄露 - 通过SSH协议可以对所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗 - SSH的另一项优点是传输的数据可以是经过压缩的，可以加快传输速度 - SSH 服务的默认端口号：22 1）常见服务默认端口号： Web 服务 80 HTTPS 443 FTP 服务 21 2）实际应用中，SSH 服务的端口号很有可能不是默认的22，这是需要使用 -p 选项指定正确的端口号，否则无法正常连接服务器 （2）SSH 这个终端命令只能在Linux或Unix系统下使用，如果在Windows系统中，可以安装 PuTTY 或者 XShell 客户端软件即可 在Windows客户端使用 ssh 服务远程登录Linux服务器的步骤： 1）在Windows客户端安装 XShell 或者 Putty 2）在Linux远程系统上安装 ssh 服务，并查看是否安装成功： sudo apt-get install openssh-server ssh -V 3）启动 ssh ，并查看是否启动成功： /etc/init.d/ssh start ps -e | grep ssh 4）注意，若远程Linux系统在虚拟机上，首先要设置虚拟机网络连接方式为“桥接网卡”， 这样虚拟机才会被看作与主机在同一局域网段中的独立的机器，才能与主机网络互相ping通。 5）检查Windows主机与Linux虚拟机之间能否互相ping通 6）若虚拟机无法ping通主机，大概率是Windows防火墙的阻止 此时需要在Windows防火墙设置中，在“入站规则”里找到配置文件类型为“公用”的“文件和打印共享（回显请求–ICMPv4-In）”规则，设置为允许 7）在Windows客户端打开XShell，新建会话，在“主机”选项中填入Linux服务端的IP地址，并根据提示填写Linux系统的用户名和密码即可登录到远程Linux服务器 （3）SSH 免密码登录 1）配置公钥： 在客户端执行 ssh-keygen 即可生成 ssh 秘钥（包含公钥id_rsa.pub和私钥id_rsa），回车三次即可 2）上传公钥到远程服务器端的 .ssh 文件夹下： 在客户端执行 ssh-copy-id [-p port] 用户名@服务端IP，即可让远程服务器记住公钥（服务器生成 authorized_keys，内容即公钥id_rsa.pub） （4）配置 ssh 远程登录的别名 1）每次输入 ssh [-p 端口号] 用户名@IP 过于麻烦，可以在客户端 ~/.ssh/ 文件夹下创建 config 文件 2）config 文件内容如下： Host 别名 HostName 远程服务器IP User 远程服务器用户名 Port SSH服务端的端口号 3）保存之后，即可使用“ssh 别名”实现远程登录，也可以使用“scp 本地文件地址 别名 远程服务器地址”将指定文件远程复制到服务器端 scp命令 scp 用来在Linux下进行远程文件拷贝 scp 命令的地址格式与 ssh 相同，在指定端口号时需使用大写-P 示例： 1 把本地当前目录下的 1.txt 文件复制到远程家目录下的 Desktop/1.txt scp -P port 1.txt user@remote:Desktop/1.txt 2 把远程家目录下的 Desktop/1.txt 文件复制到本地当前目录下的 1.txt scp -P port user@remote:Desktop/1.txt 1.txt 注意：“：”后面的路径如果不是绝对路径，则以用户家目录作为参照路径 加上 -r 选项可以复制文件夹 cp 这个终端命令只能在Linux或Unix系统下使用，在Windows系统中可以安装 PuTTY 使用 pscp 命令行工具或者安装 FileZilla 或 Xftp 使用 FTP 进行文件传输]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络]]></title>
    <url>%2F2019%2F08%2F29%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[Genius only means hard-working all one’s life. ——Mendeleyev 概述 网络（network）：若干结点和连接这些结点的链路组成（网络中结点可以是计算机、集线器、交换机、路由器） 互联网：通过路由器把网络和网络连接起来，互联网是“网络的网络” 因特网：世界上最大的互联网（网络把计算机连接在一起，因特网把网络连接在一起） 1.因特网发展的三个阶段 第一阶段：单个网络ARPANET——&gt;Internet 第二阶段：建成三级结构的互联网（主干网、地区网、校园网/企业网） 第三阶段：形成多层次ISP（Internet Service Provider）结构的因特网 2.ISP：因特网服务提供商，ISP从因特网管理机构申请到很多IP地址，同时拥有通信线路和路由器等连网设备。 3.ISP多层结构 （1）根据覆盖面积和拥有IP数目的大小，ISP分为三层：主干ISP、地区ISP、本地ISP （2）主机A要和主机B通信，需要依次经过本地ISPa、地区ISPa、主干ISPa， 主干ISPb、地区ISPb、本地ISPb一层层传输 （3）IXP：因特网交换点，它允许两个网络直接相连并交换分组，不需要通过第三个网络转发分组 4.上网：通过某个ISP获得IP，将用户主机通过ISP接入因特网 5.因特网的组成 （1）边缘部分：主机 （2）核心部分：大量网络+路由器 边缘部分利用核心部分提供的服务，使众多主机之间能够互相通信并交换、共享信息 6.路由器 实现分组交换（动态分配传输线路的资源），转发收到的分组 分组交换采用存储转发技术，将要发送的报文划分为等长的数据包/分组 7.计算机之间的通信：主机A的某个进程和主机B上的另一个进程进程通信 通信方式： （1）C/S：客户服务器方式 （2）P2P：对等方式 “三网”：电信网络、计算机网络、有线电视网络 计算机网络的分类（1）广域网WAN（因特网的核心部分）：长距离传输数据 （2）城域网MAN （3）局域网LAN：多个互联的局域网组成校园网/企业网 计算机网络的性能指标（1）速率：单位bit/s （2）带宽：通信线路允许通过的信号频带范围；表示通信线路传输数据的能力，即单位时间内通信线路所能通过的“最高数据率” （3）吞吐量：单位时间内通过某个网络的数据量（受带宽限制） （4）时延：总时延=排队时延+处理时延+发送时延+传播时延，提高数据的发送速率只是减小了数据的发送时延 （5）时延带宽积：表示从发送端发出但尚未到达接收端的比特 （6）往返时间RTT：表示从发送方发送数据开始，到发送方收到接收方的确认，总经历的时间 （7）利用率：信道利用率——某信道有百分之几的时间是被利用的 网络利用率——全网络信道利用率的加权平均值 信道或网络利用率过高会产生非常大的时延 计算机网络的体系结构1.协议 网络通信的规则，规则明确规定了：数据格式、同步问题（时序问题） 2.体系结构 计算机网络的各层及其协议的集合称为网络的体系结构 3.具有五层协议的体系结构 （1）OSI的七层协议 OSI是由国际标准化组织制定的标准，它概念清楚，理论完善，但是复杂又不实用。 7 应用层 6 表示层 5 会话层 4 运输层 3 网络层 2 数据链路层 1 物理层 （2）TCP/IP的四层协议 TCP/IP体系结构得到了非常广泛的应用 4 应用层(各种应用层协议如HTTP，FTP，DNS等) 3 运输层(TCP或UDP) 2 网际层(又名网络互联层) 1 数据链路层(又名网络接口层) （3）五层协议 学习网络原理时的体系结构，结合OSI和TCP/IP的优点 5 应用层（进程间通信和交互的规则，如HTTP，FTP等） 4 运输层（为进程间的通信提供通用的数据传输服务，如TCP,UDP） 3 网络层（为分组交换网上的不同主机提供通信服务，选择合适的路由，通过路由器找到目的主机，IP协议） 2 数据链路层（将IP数据报组装成帧在链路上传送，每一帧包括数据和控制信息——同步信息、地址信息、差错控制信息） 1 物理层 数据在各层之间的传递（1）协议数据单元PDU 计算机网络体系结构中，对等层之间交换的信息报文统称为协议数据单元（Protocol Data Unit，PDU） PDU由协议控制信息（协议头）和数据（SDU）组成 （2）各层PDU的名称 应用层 —— 报文（Message） 传输层 —— 段（Segment） 网络层 —— 分组/包（Packet） 数据链路层 —— 帧（Frame） 物理层 —— 比特（Bit） （3）PDU的封装 在计算机网络体系结构中，下层把上层的PDU作为本层的数据加以封装，然后增加本层的协议头部（和尾部）形成本层的PDU 下图为TCP/IP协议对于PDU的封装： 物理层 数据通信系统的模型一个数据通信系统分为三大部分：源系统、传输系统、目的系统 （1）源系统 源点：要传输的数据 发送器：源点数据要经过发送器编码（基带调制）后才能在传输系统中传输 典型的发送器是调制器 （2）目的系统 接收器：接收传输系统传过来的信号，解调为能被目的设备处理的信息 典型的接收器是解调器 终点：获取传输过来的数字比特流，把信息输出 宽带接入技术用户要连接到Internet，必须先连接到某个ISP，获取上网所需的IP（1）初期，利用电话线通过调制解调器连接到ISP（最高速率达到56kb/s）（2）如今，多种宽带接入技术 1.ADSL技术 （1）ADSL：非对称数字用户线，用数字技术对现有的模拟电话线进行改造，使它能够承载宽带数字业务 （2）原理：在电话线的两端各安装一个ADSL调制解调器（我国采用离散多音调DMT调制技术实现） 相当于在电话线上使用许多小的调制解调器并行地传送数据 由于用户电话线的具体条件（距离、线径、干扰等）差别很大，所以ADSL不能保证固定的数据率 ADSL采用自适应调制技术使用户线能够传送尽可能高的数据率 （3）“非对称”的含义：ADSL的下行（从ISP到用户）带宽远远大于上行（从用户到ISP）带宽 （4）ADSL的传输距离取决于：数据速率（速率越快传输距离越短）、电话线的线径（越细衰减越大） 数据链路层 数据链路层的信道：点对点信道、广播信道 数据链路层协议的任务：（1）封装成帧：在一段数据的前后添加首部和尾部，构成一帧 （2）透明传输：当传送的帧使用文本文件组成的帧，数据部分不会出现帧定界控制字符，不论键盘输入什么都可以在帧中传输过去，称为透明传输 字节填充法解决透明传输问题（发送端的数据链路层，在数据中出现控制字符时，需要在前面插入一个转义字符） （3）差错检测：在数据链路层才能广泛使用循环冗余检验CRC的检错技术 凡是接收端数据链路层接受的帧均无差错 网络层 与IP协议配套的三个协议： 地址解析协议ARP（将网络层的IP地址解析为数据链路层的硬件地址） 网际控制报文协议ICMP 网际组管理协议IGMP IP地址IP地址是给因特网上每一个主机（或路由器）的每一个接口分配一个唯一的32位的标识符 IP地址的分类如下： （1）IP地址=网络号+主机号 网络号：标志主机（或路由器）所连接的网络 主机号：标志网络号范围内的主机 （2）IP地址不仅指明一个主机，也指明了主机所连接的网络 （3）IP地址采用点分十进制记法 （4）A类地址的网络号占1个字节，主机号占3个字节 因此每一个A类网络中可指派的最大网络数为2^7-2，减2的原因：全0表示本网络，127（即01111111）保留作为本地软件环回测试本主机的进程之间的通信 最大主机数为2^24-2，减2的原因：全0代表“本主机”，全1表示该网络上的所有主机 IP地址的特点 （1）每一个IP地址都由网络号和主机号两部分组成。IP地址是一种 分等级的地址结构。分两个等级的好处是： 1&gt;IP地址管理机构在分配IP地址时只分配网络号（第一级），而剩下的主机号（第二级）则由得到该网络号的单位自行分配 2&gt;路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少， 从而减小了路由表所占的存储空间以及查找路由表的时间 （2）实际上IP地址是标志一个主机（或路由器）和一条链路的接口。由于一个路由器至少应当连接到两个网络，因此一个路由器至少应当有两个不同的IP地址。 （3）用转发器或网桥连接起来的若干个局域网仍为一个网络，因为这些局域网都具有同样的网络号。 具有不同网络号的局域网必须使用路由器进行互连 即： 1&gt;同一个局域网上的主机或路由器的IP地址中的网络号必须一致 2&gt;路由器总是有两个或两个以上的IP地址，即路由器的每一个接口都有一个不同网络号的IP地址 （4）在IP地址中，所有分配到网络号的网络（不管是范围很小的局域网，还是可能覆盖很大地理范围的广域网）都是平等的 IP地址与硬件地址 （1）硬件地址/物理地址/MAC地址：数据链路层和物理层使用的地址，位于MAC帧的首部 （2）IP地址：网络层和以上各层使用的地址，是一种逻辑地址。位于IP数据报的首部 （3）因此在数据链路层，只能看见MAC帧，不能看见IP数据报（IP地址） 划分子网在ARPANET的早期，IP地址的设计确实不够合理： IP地址空间的利用率有时很低 给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏 两级IP地址不够灵活 为解决上述问题，进行划分子网：在IP地址中又增加了一个“子网号字段＂，使两级IP地 址变成为三级IP地址（网络号+子网号+主机号） 注意：划分子网只是把IP地址的主机号这部分进行再划分，不改变网络号 子网掩码标志是否对主机号进行了子网划分因特网规定：所有的网络都必须有子网掩码，不划分子网时，使用各类IP对应的默认子网掩码 三级IP地址的子网掩码和数据报的目的IP地址逐位相“与”，得到子网的网络地址 路由表的内容：使用子网划分后，路由表必须包含三项内容——目的网络地址、子网掩码、下一跳地址 传输层 网络层与传输层的区别 （1）网络层为主机之间提供逻辑通信 传输层为进程之间提供端到端的逻辑通信 （2）在网络层，IP数据报首部中的检验和字段， 只检验首部是否出现差错而不检查数据部分 运输层还要对收到的报文进行差错检测 传输层的两个主要协议 TCP：传输控制协议，面向连接 UDP：用户数据报协议，无连接 使用UDP和TCP协议的各种应用和应用层协议： 传输层的端口 （1）把一个特定机器上运行的特定进程指明为因特网上通信最后的终点还是不可行的。 这是因为进程的创建和撤销都是动态的，通信的一方几乎无法识别对方机器上的进程。 （2）为解决上述问题，引入运输层的端口。 虽然通信的终点是应用进程，但我们只要把要传送的报文交到目的主机的某一个合适的目的端口， 剩下的工作（即最后交付给目的进程）就由TCP来完成 （3）TCP/IP的运输层用一个16位端口号来标志一个端口 用户数据报协议UDP （1）UDP只在IP的数据报服务之上增加了很少一点的功能，这就是复用和分用的功能以及差错检测的功能 （2）UDP的主要特点： 1&gt; UDP是无连接的 2&gt; UDP使用尽最大努力交付，即不保证可靠交付 3&gt; UDP是面向报文的 发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。 4&gt; UDP没有拥塞控制 因此网络出现的拥塞不会使源主机的发送速率降低。 5&gt; UDP支持一对一、一对多、多对一和多对多的交互通信 6&gt; UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短 （3）UDP的首部格式 首部字段由4个字段、8个字节组成，每个字段2个字节 1&gt; 源端口：在需要对方回信时选用，不需要时可用全0 2&gt; 目的端口：这在终点交付报文时必须要使用到 3&gt; 长度：UDP用户数据报的长度，其最小值是8 (仅有首部） 4&gt; 检验和：检测UDP用户数据报在传输中是否有错，有错就丢弃（首部和数据部分一起检验） 传输控制协议TCP （1）TCP的主要特点： 1&gt; TCP是面向连接的运输层协议 应用程序在使用TCP协议之前，必须先建立TCP连接；在传送数据完毕后，必须释放已经建立的TCP连接 2&gt; 每一条TCP连接只能有两个端点（一对一，点对点） 3&gt; TCP提供可靠交付的服务 通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达 4&gt; TCP提供全双工通信 TCP允许通信双方的应用进程在任何时候都能发送数据。 TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据 5&gt; 面向字节流 TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流，TCP并不知道所传送的字节流的含义。 （2）TCP的连接 1&gt; TCP面向连接，每条TCP连接有两个端点，端点称为套接字Socket 2&gt; 套接字Socket=IP:端口号 3&gt; 每一条TCP连接唯一地被通信两端的两个端点（即两个套接字）所确定 （3）TCP可靠传输原理 通过可靠传输协议实现： 1&gt; 停止等待协议（自动重传请求ARQ） “停止等待”就是每发送完一个分组就停止发送，等待对方的确认；在收到确认后再发送下一个分组。 a.超时重传（发送方出错） 若传输过程中出现差错，接收方不会返回确认信息，发送方超过一段时间未收到确认，就会进行“超时重传” 注意： 第一，发送方在发送完一个分组后，必须暂时保留已发送的分组的副本（为发生超时重传时使用） 第二，分组和确认分组都必须进行编号 第三，超时计时器设置的重传时间应当比数据在分组传输的平均往返时间更长一些 b.确认丢失（接收方出错） 接收方的确认丢失了，发送方就会进行超时重传，但事实上接收方已经接收到了数据 接收方需要做： 第一，丢弃这个重复的分组M2,不向上层交付 第二，向发送方重新发送确认 经过上述的确认和重传机制，就可以在不可靠的传输网络上实现可靠的通信 注意：停止等待协议信道利用率极低 为提高传输效率，采用流水线传输 流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认 2&gt; 连续ARQ协议/滑动窗口协议（流水线传输） 发送方分组发送：位于窗口中的多个分组都可以连续发出去，不需要等待对方确认 接收方累积确认：接收方不必对收到的分组逐个发送确认，而是可以在收到几个分组后，对按序到达的最后一个分组发送确认 超时重传： 确认丢失： （4）TCP的首部格式 首部占：20+4n字节，其中20个字节是固定的，4n字节根据需要增加 首部各字段： 1&gt; 源端口、目的端口 2&gt; 序号：在一个TCP连接中传送的字节流中的每一个字节都按顺序编号 3&gt; 确认号：期望收到对方下一个报文段的第一个数据字节的序号 4&gt; 数据偏移：这个字段实际上是指出TCP报文段的首部长度 5&gt; 保留：占6位，保留为今后使用，但目前应置为0 6&gt; 紧急URG：URG=1标志该报文段中包含紧急数据，应尽快发送 7&gt; 确认ACK：TCP规定，在连接建立后所有传送的报文段都必须把ACK置l 8&gt; 推送PSH 9&gt; 复位RST 10&gt; 同步SYN：建立连接时的标志。 当SYN=1而ACK=0时，表明这是一个连接请求报文段。 对方若同意建立连接，则应在响应的报文段中使SYN=1和ACK=1 因此，SYN置为1就表示这是个连接请求或连接接受报文 11&gt; 终止FIN：用来释放一个连接 当FIN=1时，表明此报文段的发送方的数据已发送完毕， 并要求释放运输连接 12&gt; 窗口：窗口指的是发送本报文段的一方的接收窗口（而不是自己的发送窗口） 窗口值作为接收方让发送方设置其发送窗口的依据 13&gt; 检验和：检验和字段检验的范围包括首部和数据这两部分 14&gt; 紧急指针：紧急指针仅在URG = 1时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据） 15&gt; 选项 （5）TCP可靠传输的实现 以字节为单位的滑动窗口 超时重传 选择确认SACK （6）TCP的流量控制 让发送方的发送速率不要太快，要让接收方来得及接收 发送方的发送窗口不能超过接收方给出的接收窗口的数值（TCP的窗口单位是字节，不是报文段） （7）TCP的拥塞控制 （8）TCP的运输连接管理 运输连接的三个阶段：连接建立，数据传送，连接释放 TCP“三次握手，四次挥手”（1）TCP的连接建立——三次握手 准备工作： 1.客户主动打开连接、服务器被动打开连接 2.B的TCP服务器进程先创建传输控制块TCB上，准备接受客户进程的连接请求。 然后服务器进程就处于LISTEN收听状态，等待客户的连接请求。如有，即作出响应 第一次握手： A的TCP客户进程也是首先创建传输控制模块TCB,然后向B发出连接请求报文段 这时首部中的同步位SYN=1，同时选择一个初始序号seq=x 这时，TCP客户进程进入SYN-SENT（同步已发送）状态 第二次握手： B收到连接请求报文段后，如同意建立连接，则向A发送确认。 在确认报文段中应把SYN位和ACK位都置1，确认号是ack=x+1，同时也为自己选择一个初始序号seq=y 这时TCP服务器进程进入SYN-RCVD（同步收到）状态 第三次握手： TCP客户进程收到B的确认后，还要向B给出确认。 确认报文段的ACK置1，确认号ack=y+1，而自己的序号seq=x+l 这时，TCP连接已经建立，A进入ESTABLISHED（已建立连接）状态 当B收到A的确认后，也进入ESTABLISHED状态 第三次握手可以携带HTTP请求报文 问题：为什么最后A还要在发送一次确认？ 答：A不想欺骗B，让服务器B一直建立着连接，等着A发送数据。事实上，A此时并没有建立连接请求。 这是由于很久之前A的连接请求在某些网络节点长时间滞留了，A在此期间重传了一次新的连接请求，完成了TCP连接和数据传输。 等到滞留的旧的连接请求抵达服务器端B，A已经释放了客户端的连接。 （2）TCP的连接释放——四次挥手 第一次挥手： A的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。 A把连接释放报文段首部的FIN置1,其序号seq=u 这时A进入FIN-WAIT-1(终止等待1)状态，等待B的确认 第二次挥手： B收到连接释放报文段后即发出确认，确认号是ack=u+1，而这个报文段自己的序号是v B就进入CLOSE-WAIT（关闭等待）状态 A收到来自B的确认后，就进入FIN-WAIT-2C终止等待2)状态，等待B发出的连接释放报文段 此时，TCP连接处于半关闭(half-close)状态：A到B的连接关闭，但B到A的连接仍开启。即A已经没有数据要发送了，但B若发送数据，A仍要接收 第三次挥手： B发出的连接释放报文段必须使FIN=1，B还必须重复上次已发送过的确认号ack=u+1 这时B就进入LAST-ACK（最后确认）状态，等待A的确认 第四次挥手： A在收到B的连接释放报文段后，必须对此发出确认。 在确认报文段中把ACK置1，确认号ack=w+1，而自己的序号是seq=u+l A进入到TIME-WAIT（时间等待）状态 注意：现在TCP连接还没有释放掉。必须经过时间等待计时器(TIME-WAITtimer)设置的时间2MSL后，A才进入到CLOSED状态（时间MSL叫做最长报文段寿命） 当A撤销相应的传输控制块TCB后，就结束了这次的TCP连接 B只要收到了A发出的确认，就进入CLOSED状态 同样，B在撤销相应的传输控制块TCB后，就结束了这次的TCP连接（B结束TCP连接的时间要比A早一些） 应用层 域名系统DNS域名系统DNS(Domain Name System)是因特网使用的命名系统，用来把便于人们使用的机器名字转换为IP地址（1）域名到IP地址的解析是由分布在因特网上的许多域名服务器程序（可简称为域名服务器）共同完成的（2）DNS的分布式结构树状结构的DNS域名服务器 每一个域名服务器都只对域名体系中的一部分进行管辖 根据域名服务器所起的作用，可以把域名服务器划分为以下四种不同的类型： 1&gt; 根域名服务器 2&gt; 顶级域名服务器TLD 3&gt; 权限域名服务器 4&gt; 本地域名服务器 万维网 WWW（1）万维网是一个大规模的、联机式的信息储藏所，英文简称为Web（2）万维网以客户服务器方式工作客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档（3）怎样标志分布在整个因特网上的万维网文档？万维网使用统一资源定位符URL来标志万维网上的各种文档，并使每个文档在整个因特网的范围内具有唯的标识符URL（4）用什么样的协议来实现万维网上各种链接？万维网客户程序与万维网服务器程序之间的交互遵守超文本传送协议HTTP（5）怎样使不同作者创作的不同风格的万维网文档都能在因特网上的各种主机上显示出来？万维网使用超文本标记语言HTML, 使得万维网页面的设计者可以很方便地用链接从本页面的某处链接到因特网上的任何个万维网页面，并且能够在自己的主机屏幕上将这些页面显示出来]]></content>
      <categories>
        <category>《计算机网络》</category>
      </categories>
      <tags>
        <tag>Internet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由JSP引出的前后端分离架构]]></title>
    <url>%2F2019%2F08%2F29%2F%E7%94%B1JSP%E5%BC%95%E5%87%BA%E7%9A%84%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[The man with a new idea is a crank until the idea succeeds.——Mark Twain 写在前面今天写了一天项目申请书，心累。说说昨天在学习JSP时想到的一个问题，以及由此引发的我一连串的百度搜索… 为什么要有JSP这么个东西？ 有了Servlet为什么要有JSP刚接触的时候，老师由这个问题引出了JSPServlet和JSP都属于动态web资源，都是服务器端的技术，需要启动服务器后才会执行，那它俩有啥区别呢？为什么有了Servlet为什么要有JSP？ Servlet是一种运行在服务器端的java小程序，它通常通过http协议接收和响应来自web客户端的请求。 有人说JSP就是Servlet，我觉得有一定道理：服务器在读到JSP代码后，根据相应的业务逻辑，编译成相应的servlet程序，再由servlet输出到页面（输出的就是html），但Servlet可能更偏向于逻辑的实现，而JSP偏向于与HTML页面相关的操作 Servlet程序中还可以编写前端HTML页面：response.getWriter(&quot;HTML代码&quot;) 但是用Servlet生成HTML页面有不可避免的缺点： 1. 代码量大 2. 每一个servlet程序都需要配置 3. 要求开发人员十分了解java，不利于前后端分离，不便于页面的调试、维护 老师由此引出了JSP，但后来我发现JSP并没有完全解决上面存在的问题啊 1. JSP文件不需要像Servlet一样在服务器端进行配置web.xml，就能在浏览器端访问。这算解决了第二个问题 2. 可是，JSP可以用来编写HTML+java+JSP代码，这些代码那么乱的结合在一起，也没有解决前后端分离的问题，相反我觉得问题更严重了 到这儿问题又来了：为什么一定要做到前后端分离，有什么好处？有没有必要？ 前后端分离的架构 这一部分摘自LIDADA博客 传统开发模式这种方式的特点是利用后端语言提供的模板引擎生成html页面，再经服务器返回到客户端浏览器中。而浏览器就只需要解析这些代码就行了。 常见的开发方式有： PHP语言的Smarty模板引擎与Thinkphp框架Java语言的Freemarker模板引擎与Jsp页面 Ajax请求Ajax是前后端分离的推进者，使用Ajax后，网页可以实现局部刷新，不需要再依靠刷新页面对网页中的内容进行更新了。同时后台仅需要给前台暴露出前台需要的各种API接口，并对前台提供的接口数据进行增删改查就可以了。这无疑也剩下了很多工作量，也为前端的下一步发展打下了基础。 前端构建与请求传统开发模式中，前端的所有文件都放在了后台的server中。后端的项目通常都会有自己的server，除了php以外。前端构建的话，前端项目也要搭建一个server，然后把前端的项目放到apache或者nginx中。或者利用nodeJs工具集。 现在前后端分离开了，当然也涉及到请求的问题。这时我们只需要告诉后端服务我们需要的数据就可以了。但这样会产生一个问题，Ajax跨域问题。在这里我们不能用常用的jsonp或者iframe信使等去解决问题，因为我们还有POST请求。 所以HTTP Proxy类工具就可以用到了，比如我再BrowserSync加入中间件判断每一个请求，如果是/api为前缀的就会被代理到API Server端，API server端接收到数据后再返回给BrowserSync，然后BrowserSync再返回给浏览器。 生产环境可以前后端分开部署，只需要在前端的server中写好转发规则就可以了，apache和nginx都支持的。 总结 前后端分离的优势： 前端静态资源与后台api分流，互不影响 前后台同步开发，减少沟通成本 方便开发调试，不影响工作进度 易于维护扩展 前后端分离缺点： 前端负载增加 不利于搜索引擎优化 一些理解 前端使用HTML+Ajax，后端使用Java Servlet，这样完全可以做到前后端分离。前端哪天换成了移动App或者桌面App，后端程序可重用、无需重新开发；而后端服务如果需要换成.Net或PHP，前端也可完全重用，前后端做到100%解耦，这就是前后端分离的架构思想。 大型的项目肯定是HTML+AJAX，HTML只要浏览器便能解析了，像JSP还要服务器解析编译。jsp这种只能在自己的小项目或者后台系统，像平台级的项目都是HTML+AJAX，这样前后端分离，前后端可以同时由不同的分工开发。 如果你注重安全和浏览器响应效率，可以用html，毕竟他是静态网页，加上ajax相当于给他动态行为如果你注重开发效率，可以用jsp， 毕竟他封装的比较多,用起来肯定爽的多 jsp是页面先加载数据，ajax是页面后加载数据，这个对搜索引擎的影响很大，若你是做系统之类的项目不需要搜索引擎收录，那区别不大，也就点点效率问题。可是要考虑收录的话你用ajax的方式后加载数据会让搜索引擎获取不到这些内容，你的页面能呈现的只是那些静态的内容，无论你ajax获取的数据有多不同，有多少个页面，对于搜索引擎来说那就是一个页面，因为呈现的内容是一样的 总结 HTML+ajax 有利于前后端分离，便于后期维护，便于前端代码的移植 HTML浏览器响应效率高，还可以将动静态资源分离，HTML部署在nginx上，效率更高 安全 JSP 封装较多，开发效率高 如果需要考虑搜索引擎收录，由于jsp是页面先加载数据，ajax是页面后加载数据，那么用ajax的方式后加载数据会让搜索引擎获取不到这些内容，你的页面能呈现的只是那些静态的内容 比较好的相关文章先收着，指不定哪天就醍醐灌顶了 Web研发模式演变 浅谈架构之路——前后端分离模式 从经典的JSP+Servlet+JavaBean的MVC时代，到SSM（Spring + SpringMVC + Mybatis）和SSH（Spring + Struts + Hibernate）的Java 框架时代，再到前端框架（KnockoutJS、AngularJS、vueJS、ReactJS）为主的MVC时代，然后是Nodejs引领的全栈时代，技术和架构一直都在进步。]]></content>
      <categories>
        <category>钻牛角尖</category>
      </categories>
      <tags>
        <tag>JSP</tag>
        <tag>HTML+ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM（二）]]></title>
    <url>%2F2019%2F08%2F29%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[A contented mind is the greatest blessing a man can enjoy in this world. 虚拟机执行子系统 虚拟机执行子系统 类文件结构 虚拟机类加载机制 虚拟机字节码执行引擎 类文件结构一次编写，到处运行：虚拟机提供商发布了可以运行在各种不同平台上的虚拟机，这些虚拟机都可以载入和运行相同的字节码。虚拟机并不关心Class文件的来源是何种语言。 Class文件格式 Class文件的数据结构：无符号数、表（1）无符号数（基本数据类型）：用来描述数字、索引引用、数值量，或者按照UTF-8编码构成字符串值，u1、u2、u4、u8（2）表（复合数据类型）：用于描述有层次关系的复合结构的数据，以“_info”结尾 Class文件格式Class的结构没有任何分隔符，所以上表中的数据项，无论是顺序还是数量都是被严格限定的（1）魔数与Class文件的版本魔数（Magic Number）：唯一作用是确定这个文件是否是一个能被虚拟机接受的Class文件版本号（Minor Version、Major Version）（2）常量池Class文件的资源仓库，主要存放字面量、符号引用。 字面量：文本字符串、声明为final的常量值。 符号引用：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。 常量池的特点： 1.是Class文件结构中与其他项目关联最多的数据类型 2.占用空间最大的数据类型 3.Class文件中第一个出现的表类型数据 （3）访问标志用于识别类或接口的访问信息（4）类索引、父类索引、接口索引集合Class文件中由这三项数据来确定这个类的继承关系（5）字段表集合用于描述接口或类中声明的变量（6）方法表集合用于描述接口或类中声明的方法（7）属性表结合在Class文件、字段表、方法表中都可以携带自己的属性表集合，用于描述某些场景下专有的信息 字节码指令Java虚拟机的指令有一个字节长度的操作码（代表某种特定的操作）和操作数（操作所需参数）构成。大多数的指令都包含了其操作所对应的数据类型信息，例如iload指令用于从局部变量表中加载int型的数据到操作数栈中（1）加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输（2）运算指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。大体可分为：操作整形数据的指令、操作浮点型数据的指令（3）类型转换指令将两种不同的数值类型进行相互转换，这些转换操作一般用于实现用户代码中的显式类型转换操作（4）对象创建与访问指令获取对象实例或者数组实例中的字段或数组元素（5）操作数栈管理指令用于直接操作操作数栈（6）控制转移指令让Java虚拟机有条件或无条件地从指定位置的指令继续执行程序（7）方法调用和返回指令方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的（8）异常处理指令显式抛出异常的操作（throw语句）都由athrow指令来实现处理异常（catch语句）不是由字节码指令实现，而是采用异常表完成（9）同步指令方法级同步：隐式，无序通过字节码之灵来控制，实现在方法调用和返回操作之中方法内部一段指令序列的同步 虚拟机类加载机制类加载机制：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型 为什么称Java为动态扩展语言？运行期动态加载和动态连接，虽然令类加载时增加了性能开销，但为java应用程序提供了高度的灵活性 类的生命周期 加载、验证、准备、初始化和卸载这5个阶段的开始顺序是确定的，强调开始是因为这些阶段通常都是互相交叉混合执行的。 什么时候开始类加载过程的第一个阶段——“加载”？没有强制约束 对于初始化阶段，严格规定有且只有5种情况必须立即对类进行“初始化”，这5种场景中的行为称为对一个类进行主动引用 加载、验证、准备需要在初始化之前开始 类加载的过程 加载加载阶段完成后：（1）通过一个类的全限定名获取定义此类的二进制字节流；（2）虚拟机外部的二进制字节流按照虚拟机所需的格式存储在方法区；（3）内存中实例化一个java.lang.Class类的对象（在方法区中），这个对象将作为程序访问方法区中的这些类型数据的外部接口 验证（1）作用：确保Class文件的字节流中包含的信息符合当前虚拟机的要求（2）大致分为四个阶段：文件格式验证、元数据验证、字节码验证、符号引用验证（3）验证阶段重要，但不必要 准备（1）作用：为类变量分配内存、设置类变量初始值（类变量存储在方法区中）（2）准备阶段分配内存是给类变量分配内存，不包括实例变量（3）设置初始值通常是零值 解析虚拟机将常量池内的符号引用替换为直接引用 初始化（1）除了加载阶段用户可自定义类加载器，验证、准备、解析完全由虚拟机主导和控制（2）初始化阶段，才真正开始执行用户代码（3）初始化阶段是执行类构造器&lt; clinit &gt;()方法的过程 类加载器类加载器：虚拟机外部，用来引导“类加载”过程的“加载”阶段执行的代码模块 作用（1）用于实现类的加载动作（2）类加载器和类本身一起，用于确定一个类在Java虚拟机中的唯一性 类加载器类型（1）启动类加载器（Bootstrap ClassLoader）：虚拟机自身的一部分，由C++实现（2）所有其他的类加载器，独立于虚拟机外部，由Java实现，全都继承自抽象类java.lang.ClassLoader 扩展类加载器 应用程序类加载器（系统类加载器）：程序中默认的类加载器 类加载器之间的层次关系——双亲委派模型双亲委派模型：类加载请求会优先委派给父类加载器去完成好处：Java类随着他的类加载器一起具备了一种带有优先级的层次关系，这对于保证Java程序的稳定运作很重要 虚拟机字节码执行引擎执行引擎是Java虚拟机最核心的组成部分之一从外观上看，所有的Java虚拟机的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码的等效过程，输出的是执行结果 运行时栈帧结构 栈帧是虚拟机进行方法调用和方法执行的数据结构 栈帧与方法一一对应 栈帧存储了方法的局部变量表、操作数栈、动态连接、返回值地址等信息 栈帧是运行时数据区中的虚拟机栈的栈元素 对执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，成为当前栈帧，对应的方法称为当前方法 执行引擎运行的所有字节码指令都只对当前栈帧进行操作 局部变量表（1）用于存放方法参数和方法内部定义的局部变量（2）在Java程序编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量（3）局部变量表的容量以变量槽slot为最小单位（4）虚拟机通过索引定位的方式使用局部变量表，索引值的范围从0开始至局部变量表最大的Slot数量（5）局部变量表不存在类似类加载的“准备阶段”，因此如果一个局部变量定义了但没有赋初始值是不能使用的 操作数栈（1）存储方法执行过程中的数据（2）后入先出LIFO（3）同局部变量表一样，操作数栈的最大深度也在编译时写在方法的Code属性的max_stacks数据项中（4）方法开始执行时，操作数栈是空的；方法执行过程中，会有各种字节码指令往操作数栈中写入和提取内容（入栈/出栈）（5）操作数栈中元素的数据类型必须与字节码指令的类型严格匹配（6）栈帧重叠：下面栈帧的操作数栈和上面栈帧的局部变量表重叠，这样在方法调用时就可以共用一部分数据，无需进行额外的参数复制传递 动态连接每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，这个引用是字节码方法调用指令的参数。（1）静态解析常量池中一部分符号引用会在类加载阶段或者第一次使用的时候转化为直接引用（2）动态连接另外一部分符号引用胡子爱每一次运行期间转化为直接引用 方法返回地址退出方法的两种方式：（1）正常完成出口：执行引擎遇到任意一个方法返回的字节码指令（是否有返回值和返回值的类型由方法返回指令决定）（2）异常完成出口：方法执行过程中遇到了异常，并且异常没有在方法体中得到处理（不会给上层调用者产生任何返回值） 方法调用Class文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在Class文件中存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（直接引用） 静态解析类加载的解析阶段，将一部分符号引用转化为直接引用包括两类方法：静态方法、私有方法 分派（多态性）（1）静态分派所有依赖静态类型来定位方法执行版本的分派动作称为静态分派静态分派发生在编译阶段，不由虚拟机执行典型应用：重载（2）动态分派在隐形器根据实际类型确定方法执行版本的分派过程称为动态分派典型应用：重写 动态类型语言动态类型语言的关键特征是它的类型检查的主题过程是在运行期而不是编译期]]></content>
      <categories>
        <category>《深入理解JVM》</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM（三）]]></title>
    <url>%2F2019%2F08%2F29%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[The greater a man is, the more distasteful is praise and flattery to him. Java内存模型、线程、线程安全、锁优化 Java内存模型 衡量一个服务（程序）性能的好坏——每秒事务处理数（TPS），TPS与程序的并发能力密切相关 实现并发编程的工具 Java语言和虚拟机提供的很多工具 中间件服务器 各类框架 硬件的效率与一致性 硬件效率高速缓存：解决了处理器与内存之间的速度矛盾 缓存一致性问题当多个处理器的运算任务涉及同一块主内存区域时，可能导致各自的缓存数据不一致 此时，需要各个处理器访问缓存时遵循一些协议，根据协议进行读写操作 主内存与工作内存类似于硬件的效率与一致性问题：工作内存解决了Java线程与主内存之间的速度矛盾，但是引入了线程安全的问题 Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存 线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量 内存间交互操作 内存间交互操作：一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存 Java内存模型中定义了8中原子性的操作实现主内存与工作内存之间的交互 lock unlock read load use assign store write 线程读取主内存变量的过程 volatile型变量 volatile是Java虚拟机提供的最轻量级的同步机制 volatile作用： 保证变量对所有线程的可见性 禁止指令重排序优化（普通的变量不能保证变量赋值操作的顺序与程序代码中的执行顺序一致） 原子性、可见性、有序性Java内存模型是围绕着在并发过程中如何处理原子性、可见性、有序性这3个特征来建立的 原子性 基本数据类型的访问读写是原子性的 synchronized块之间的操作也具备原子性 可见性当一个线程修改了共享变量的值，其他线程能立即得知这个修改（1）Java内存模型实现可见性的途径变量修改后将新值同步回主内存，修改前从主内存刷新变量值（依赖于主内存作为传递媒介），普通变量、volatile变量都是如此（2）volatile变量与普通变量的区别volatile修饰的变量：新值立即同步，每次使用前立即从主内存刷新（3）实现可见性的关键字：volatile、synchronized、final 有序性（1）本线程内观察，所有的操作都是有序的——线程内表现为串行（2）如果在一个线程中观察另一个线程，所有的操作都是无序的——指令重排序现象（3）实现有序性的关键字：volatile、synchronized Java线程线程的实现线程的3中实现方式：使用内核线程实现、使用用户线程实现、使用用户线程加轻量级进程混合实现 使用内核线程（KLT）实现 由操作系统内核完成线程切换——内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上 程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口——轻量级进程（LWP），与内核线程一一对应（就是通常意义上的线程） 优点：每个轻量级进程都是一个独立的调度单元，一个阻塞了不影响其他 缺点：基于内核线程实现，所以各种线程操作都需要进行系统调用，系统调用代价较高，需要在用户态和内核态之间来回切换；消耗内核资源 使用用户线程实现 优点：不需要内核支援 缺点：所有线程操作都需要用户程序自己处理 使用用户线程加轻量级进程混合实现 Java线程的实现：一条Java线程——一条轻量级进程——一条内核线程 线程的调度 协同式线程调度 抢占式线程调度：每个线程由系统来分配执行时间 线程优先级：Java提供了10个级别的线程优先级 线程状态转换 线程状态 新建 运行 无限期等待 限期等待 阻塞 结束 线程状态转换 线程安全Java线程安全的分类按线程安全的“安全程度”分为5类： 不可变——final 绝对线程安全 相对线程安全——通常意义的线程安全 线程兼容——通常意义的线程不安全 线程对立线程安全的实现方法 互斥同步（synchronized、ReentrantLock）（1）synchronized是Java语言中一个重量级的操作，使用它需要java线程映射到内核线程，通过操作系统内核来实现同步，耗费很多处理器时间（2）ReentrantLock相比synchronized增加了三项高级功能： 等待可中断 公平锁 锁绑定多个条件（3）优先考虑使用synchronized来进行同步 非阻塞同步（1）互斥同步进行线程阻塞和唤醒会带来性能问题，互斥同步属于一种悲观的并发策略（认为不进行同步处理肯定出问题）（2）非阻塞同步（乐观的并发策略）：先进行操作，没有其他线程争用共享数据则操作成功；有其他线程争用共享数据则采取补偿措施 无同步方案 可重入代码（纯代码），所有的可重入代码都是线程安全的 线程本地存储 锁优化 锁优化目的在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率 锁优化技术 适应性自旋 锁消除 锁粗化 轻量级锁 偏向锁]]></content>
      <categories>
        <category>《深入理解JVM》</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM（一）]]></title>
    <url>%2F2019%2F08%2F29%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%2F</url>
    <content type="text"><![CDATA[The shortest way to do many things is to only one thing at a time. 自动内存管理机制 为啥学JVM 在绝大多数情况下，提升硬件性能无法等比例地提升程序的运作性能和并发能力。 这里面有Java虚拟机的原因：为了达到给所有硬件提供一致的虚拟平台的目的，牺牲了一些与硬件相关的性能特性。 当开发人员了解了JVM的运行原理，才能写出最适合虚拟机运行和自优化的代码。 相关知识点梳理1. 自动内存管理机制 内存动态分配 运行时数据区域 内存溢出异常 垃圾自动回收 垃圾收集算法 垃圾收集器 内存分配与回收策略 2. 虚拟机执行子系统 Class类文件的结构 虚拟机类加载机制 类加载的时机和过程 类加载器 虚拟机字节码执行引擎 3. 高效并发 Java内存模型 Java线程 线程安全与锁优化 线程安全 锁优化 自动内存管理机制内存区域 上图中：绿色区域——所有线程共享的数据区黄色区域——线程隔离的数据区 1. 程序计数器：当前线程正在执行的字节码指令的地址 （1）每条线程都有一个独立的程序计数器 （2）如果线程执行Java方法，则计数器记录的是正在执行的字节码问指令的地址 （3）如果执行的是Native方法，则计数器值为空（Undefined） （4）此区域是唯一一个在Java虚拟机规范中没有滚定任何OutOfMemoryError情况的区域 2. 虚拟机栈：描述的是Java方法执行的内存模型。每个方法执行时都会创建一个栈帧（Stack Frame），用于存储局部变量表等…局部变量表中包括：基本数据类型、对象引用、return Address类型 3. 堆：虚拟机启动时创建，唯一目的是存储实例对象（包括数组） Java堆是内存管理的主要区域，因此也称“GC堆” 4. 方法区：用于存储已被虚拟机加载的类信息、常量、静态变量等… 5. 常量池：存放编译期生成的各种字面量和符号引用 虚拟机中的对象对象的创建（5步） 检查类的符号引用，执行类加载过程检查：new指令的参数与是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已经被加载 分配内存（1）分配方式：指针碰撞（java堆中的内存是规整的）；空闲列表（java堆中的内存不规整） （2）内存区域是否规整由所采用的垃圾收集器是否带有压缩整理功能决定 初始化为零值 设置对象头 执行init()方法，按照程序员的意愿初始化 对象的内存布局 对象头 对象自身的运行时数据（哈希码、GC分代年龄、线程持有的锁…） 类型指针 记录数组长度的数据（数组特有） 实例数据部分：对象真正存储的有效信息 对齐填充对象的大小必须是8字节的整数倍，所以需要占位符来填充 对象的访问定位Java程序需要通过栈上的引用数据来操作堆上的具体对象，主流的对象的访问方式有两种：句柄访问、直接指针 句柄访问：堆中划分一块内存作为句柄池，栈中存储的是对象的句柄地址 直接指针：栈中存储的直接就是对象地址 判断对象是否存活1. 引用计数算法（1）给对象中添加一个引用计数器，引用一次+1，引用失效-1。则引用计数器为0的对象就是不可能再被使用的（2）不能解决对象之间互相循环引用的问题 2. 可达性分析算法（1）起始点：一系列GC Roots对象 虚拟机栈中引用的对象 方法区中静态变量引用的对象 方法区中常量引用的对象 本地方法栈中JNI（Native方法）引用的对象 （2）引用链（Reference Chain）：从起始点出发的搜索路径（3）当一个对象到起始点的没有任何引用链相连，则证明此对象不可用 3. 引用的概念（1）JDK1.2之前，引用定义为：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用（2）JDK1.2后，java对引用概念进行了扩充，分为： 强引用：永远不回收 软引用：将要溢出才回收，SoftReference类实现 弱引用：必定回收，WeakReference类实现 虚引用：被关联对象被回收时会显示系统通知，PhantomReference类实现 4. 对象被GC的条件如上图所示，真正宣告一个队形死亡，至少要经理两次标记过程 第一次判断对象是否与GC Roots相连，不相连则做“筛选标记” 第二次判断对象是否重新关联引用链，关联了则做“复活标记” 关于finallize()方法需要注意：（1）任何一个对象的finallize()方法都只会被系统自动调用一次（2）如果对象面临下一次回收，它的finallize()方法不会再执行，对象就无法自救了（3）不建议使用finallize()方法 垃圾收集算法1. 标记-清除算法（Mark-Sweep）首先标记出需要回收的对象，标记完成后统一回收不足： 效率问题——标记和清除的效率低 空间问题——清除后产生大量不连续的内存碎片 2. 复制算法（Copying）将内存分为较大的一块Eden区和两块较小的Survivor区，每次使用Eden和其中一块Survivor。（HotSpot虚拟机中Eden：Survivor=8:1）回收时，将Eden和Survivor中还存活的对象一次性复制到另外一块Survivor空间上，清理掉Eden和刚才用过的Survivor空间。 3. 标记-整理算法（Mark-Compact）标记过程和“标记-清理”算法一致，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后清理掉端边界以外的内存。 4. 分代收集算法（1）新生代：复制算法新生代中，每次垃圾收集时都会有大量的对象死去，只有少量存活（2）老年代：标记-清理算法、标记-整理算法老年代中对象存活率高，没有额外空间对它进行分配担保 垃圾收集器从JDK1.3到JDK1.7，GC的发展历程： JDK1.3：Serial收集器（包括Serial Old） Parallel收集器（包括ParNew、JDK1.4：Parallel Scavenge、JDK1.6：Parallel Old） JDK1.5：Concurrent Mark Sweep（CMS）——第一款真正意义上的并发（Concurrent）收集器；实现了垃圾收集线程和用户线程基本上同时工作 JDK1.7：Garbage First（G1） 1. Serial收集器（新生代）（1）单线程（2）Stop The World：Serial进行垃圾收集时，必须暂停其他所有的工作线程（直到最新G1收集器出现，这个问题也没有完全解决，只是用户线程的暂停时间越来越短了）（3）JVM在Client模式下的默认新生代收集器（4）优点：简单、高效 2. ParNew收集器（新生代）（1）Serial收集器的多线程版本：使用多个线程进行垃圾收集（2）JVM在Server模式下首选的新生代收集器（3）除了Serial收集器外，只有ParNew能与CMS收集器配合使用（Parallel Scavenge不能配合CMS） 区分并发与并行 并行（Parallel）：指多条垃圾回收线程并行工作，但此时用户线程仍然处于等待状态 并发（Concurrent）：指用户线程和垃圾处理线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续执行，而垃圾收集程序运行在另一个CPU上 3. Parallel Scavenge收集器（新生代）（1）其他收集器关注GC时用户线程的停顿时间，Parallel Scavenge收集器的目标是达到一个可控的吞吐量，因此又称“吞吐量优先”收集器 吞吐量 = 运行用户代码时间 / （运行用户代码时间+垃圾收集时间） （2）停顿时间短：适合用户交互式程序 吞吐量大：适合非交互的运算任务 停顿时间与吞吐量成反比 （3）Parallel Scavenge收集器有一个开关参数，打开后就可以动态调整细节参数（新生代大小、Eden与Survivor比例、晋升老年代对象大小等），以提供最适合的停顿时间/吞吐量——GC自适应的调节策略 4. Serial Old收集器（老年代）（1）单线程，标记-整理算法（2）主要给Client模式下的JVM使用（3）Server模式下，与Parallel Scavenge收集器搭配使用，或者作为CMS收集器的备选 5. Parallel Old收集器（老年代）（1）多线程，标记-整理算法（2）Parallel Old是Parallel Scavenge收集器的老年代版本，一般配合Parallel Scavenge，实现“吞吐量优先” 6. CMS收集器（老年代）（1）目标：获取最短回收停顿时间（2）第一款真正意义上的并发（Concurrent）收集器；实现了垃圾收集线程和用户线程基本上同时工作（3）标记-清除算法（4）步骤 初始标记（CMS initial mark） 并发标记（CMS concurrent mark） 重新标记（CMS remark） 并发清除（CMS concurrent sweep） 初始标记、重新标记两个步骤仍然要“Stop The World”，但这两个阶段的停顿时间很短； 整个过程中并发标记和并发清除耗时最长，但收集器线程都可以与用户线程一起工作； 所以，总体来说，CMS收集器的内存回收过程食欲用户线程一起并发执行的。 （5）CMS的优点：并发收集、低停顿时间缺点：CMS收集器对CPU资源非常敏感；无法处理浮动垃圾；CMS基于“标记-清除”算法，效率低、产生大量碎片空间 7. G1收集器]]></content>
      <categories>
        <category>《深入理解JVM》</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试图片]]></title>
    <url>%2F2019%2F08%2F29%2F%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[Hello picture. 问题之前博客中的图片都无法正常显示了 解决办法 在 /Blog/source 目录下新建文件夹，命名为”myimages” 将带引用的图片放入 myimages 文件夹下 在博文中利用markdown语法引入图片： 1![](/myimages/图片文件名) 把之前的所有博文中的图片都按照上面的方法重新引用了，还好不多-_-||]]></content>
      <categories>
        <category>hello hexo</category>
      </categories>
      <tags>
        <tag>修改图片问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F08%2F29%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Never put off what you can do today until tomorrow. 正则表达式语法 常用正则表达式 邮箱正则 /^([a-zA-Z0-9_.-])+\@(([a-zA-Z0-9-])+.)+([a-zA-Z0-9]{2,4})+$/ /.+@.+.[a-zA-Z]{2,4}$/ 正则应用字符串匹配（验证Email是否正确）public static void main(String[] args) { // 要验证的字符串 String str = &quot;service@xsoftlab.net&quot;; // 邮箱验证规则 String regEx = &quot;[a-zA-Z_]{0,}[0-9]{0,}@(([a-zA-z0-9]-*){1,}\\.){1,3}[a-zA-z\\-]{1,}&quot;; // 编译正则表达式 Pattern pattern = Pattern.compile(regEx); // 忽略大小写的写法 // Pattern pat = Pattern.compile(regEx, Pattern.CASE_INSENSITIVE); Matcher matcher = pattern.matcher(str); // 字符串是否与正则表达式相匹配 boolean rs = matcher.matches(); System.out.println(rs); } 一种更简单的方式： String regEx = &quot;[a-zA-Z_]{0,}[0-9]{0,}@(([a-zA-z0-9]-*){1,}\\.){1,3}[a-zA-z\\-]{1,}&quot;; System.out.println(&quot;service@xsoftlab.net&quot;.matches(regEx)); 字符串查找（在字符串中查找符合规则的子串）public static void main(String[] args) { // 要验证的字符串 String str = &quot;这是一个正则表达式字符串查找的示例12345，正则表达式好厉害呀45678&quot;; // 正则表达式规则 String regEx = &quot;\\d+&quot;; // 编译正则表达式 Pattern pattern = Pattern.compile(regEx); // 忽略大小写的写法 // Pattern pat = Pattern.compile(regEx, Pattern.CASE_INSENSITIVE); Matcher matcher = pattern.matcher(str); // 查找字符串中是否有匹配正则表达式的字符/字符串 while (matcher.find()) { System.out.println(matcher.group()); } } 输出结果： 12345 45678 贪婪模式与非贪婪模式 正则表达式默认使用贪婪模式，会尽可能多的匹配所搜索的字符串 当”?”字符紧跟在任何一个其他限制符 (*, +, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串 贪婪模式public static void main(String[] args) { // 要验证的字符串 String str = &quot;这是一个正则表达式字符串查找的示例，正则表达式好厉害呀&quot;; // 编译正则表达式 Pattern pattern = Pattern.compile(&quot;正.*式&quot;); // 开始匹配 Matcher matcher = pattern.matcher(str); // 查找字符串中是否有匹配正则表达式的字符/字符串 while (matcher.find()) { System.out.println(matcher.group()); } } 输出： 正则表达式字符串查找的示例，正则表达式 非贪婪模式public static void main(String[] args) { // 要验证的字符串 String str = &quot;这是一个正则表达式字符串查找的示例，正则表达式好厉害呀&quot;; // 编译正则表达式 Pattern pattern = Pattern.compile(&quot;正.*?式&quot;); // 开始匹配 Matcher matcher = pattern.matcher(str); // 查找字符串中是否有匹配正则表达式的字符/字符串 while (matcher.find()) { System.out.println(matcher.group()); } } 输出： 正则表达式 正则表达式]]></content>
      <categories>
        <category>小知识点</category>
      </categories>
      <tags>
        <tag>RegExp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[易错点-正则+反射+IO流+网络编程]]></title>
    <url>%2F2019%2F08%2F29%2F%E6%98%93%E9%94%99%E7%82%B9-%E6%AD%A3%E5%88%99-%E5%8F%8D%E5%B0%84-IO%E6%B5%81-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[正则；反射；IO流；网络编程和JavaWeb 正则 反射1 反射破坏代码的封装性，破坏原有的访问修饰符访问限制 IO流1 一个文件中的数据要在控制台上显示，首先要把这个文件读进来，然后再输出，所以首先要建立文件输入流FileInputStream，然后再建立标准输出流 System.out 2 File类 （1）File类是Java中对文件进行读写操作的基本类（×） （2）File类是对文件整体或者文件属性操作的类，例如创建文件、删除文件、查看文件是否存在等功能。 File类不能操作文件内容，文件内容是用IO流操作的。 （3）不论是文本文件还是二进制文件，在计算机中都是以二进制形式存储的，所以都当做二进制文件读取 3 使用ObjectOutputStream和ObjectInputStream可以将对象进行传输 4 哪个类可用于处理Unicode? 答：InputStreamReader可以指定字符编码格式 网络编程/JavaWeb1 Web工程的目录结构 /WEB-INF/web.xml 是部署描述文件，用来初始化配置信息 /WEB-INF/classes 用来放置应用程序用到的自定义类(.class)，必须包括包(package)结构 /WEB-INF/lib 用来放置应用程序用到的JAR文件 2 Socket通信编程 客户端通过new Socket()方法创建通信的Socket对象 服务器端通过new ServerSocket()创建TCP连接对象 accept接纳客户端请求 3 connect()属于客户端，将此套接字连接到服务器 4 URL一般有四部分组成： &lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt; &lt;主机&gt;是指主机在因特网上的域名。 http协议的默认&lt;端口&gt;为80（可以省略） 5 判断：service()方法处理客户机发出的所有请求 （√） 解析：service()是servlet真正处理客户端传过来的请求的方法，由web容器调用，根据HTTP请求方法（GET、POST等），将请求分发到doGet、doPost等方法 6 service()方法是接收请求，返回响应的方法 每次请求都执行一次，该方法被HttpServlet封装为doGet和doPost方法 service()是在javax.servlet.Servlet接口中定义的 doGet/doPost是在javax.servlet.http.HttpServlet中实现的 7 servlet和CGI （1）servlet处于服务器进程中，它通过多线程方式运行其他service方法 （2）CGI对每个请求都产生新的进程，服务完成后销毁 （3）CGI不可移植。为某一特定平台编写的CGI应用只能运行于这一运行环境中 8 ServletContext、ServletConfig （1）ServletContext中可以存放共享数据。ServletContext对象是真正的一个全局对象，凡是web容器中的Servlet都可以访问 （2）ServletConfig对象：用于封装servlet的配置信息（初始化参数），ServletConfig接口默认是通过GenericServlet实现的 9 判断：servlet在多线程下使用了同步机制，因此，在并发编程下servlet是线程安全的 （×） 10 2EE中，使用Servlet过滤器，需要在web.xml中配置什么元素？ 答： Servlet过滤器的配置包括两部分： 第一部分是过滤器在Web应用中的定义，由&lt;filter&gt;元素表示，包括&lt;filter-name&gt;和&lt;filter-class&gt;两个必需的子元素 第二部分是过滤器映射的定义，由&lt;filter-mapping&gt;元素表示,可以将一个过滤器映射到一个或者多个Servlet或JSP文件， 也可以采用url-pattern将过滤器映射到任意特征的URL 11 forward：服务器获取跳转页面内容传给用户，用户地址栏不变 redirect：是服务器向用户发送转向的地址，redirect后地址栏变成新的地址 12 取http请求中的cookie值的方法：request.getHeader、request.getCookies 13 HttpServletResponse功能：设置http头标，设置cookie，设置返回数据类型，输出返回数据 HttpServletRequest功能：读取路径信息... 14 getParameter()是获取POST/GET传递的参数值 getInitParameter获取Tomcat的server.xml中设置Context的初始化参数 getAttribute()是获取对象容器中的数据值 getRequestDispatcher是请求转发 15 有四种方法可以实现会话跟踪技术：URL重写、隐藏表单域、Cookie、Session 16 WebServer Webservice是跨平台，跨语言的远程调用技术; 它的通信机制实质就是xml数据交换; 它采用了soap协议（简单对象协议）进行通信 17 JSP （1）Jsp只会在客户端第一次发请求的时候被编译，之后的请求不会再编译，同时tomcat能自动检测jsp变更与否，变更则再进行编译。 （2）第一次编译并初始化时调用：init()；销毁调用：destroy()。在整个jsp生命周期中均只调用一次 18 JSP分页代码中先取总记录数，得到总页数，最后显示本页的数据 19 JSP内置对象 request对象、response对象、session对象、out对象、 page对象、application对象、exception对象、 pageContext对象、config对象 20 JSP 四大作用域：page (作用范围最小)、request、session、application（作用范围最大） （1）存储在application对象中的属性可以被同一个WEB应用程序中的所有Servlet和JSP页面访问。（属性作用范围最大） （2）存储在session对象中的属性可以被属于同一个会话（浏览器打开直到关闭称为一次会话，且在此期间会话不失效）的所有Servlet和JSP页面访问。 （3）存储在request对象中的属性可以被属于同一个请求的所有Servlet和JSP页面访问（在有转发的情况下可以跨页面获取属性值） 例如使用PageContext.forward和PageContext.include方法连接起来的多个Servlet和JSP页面。 （4）存储在pageContext对象中的属性仅可以被当前JSP页面的当前响应过程中调用的各个组件访问 例如，正在响应当前请求的JSP页面和它调用的各个自定义标签类 21 JSP中静态include和动态include： （1）动态 INCLUDE 用 jsp:include 动作实现 &lt;jsp:include page=&quot;included.jsp&quot; flush=&quot;true&quot; /&gt; 它总是会检查所含文件中的变化 , 适合用于包含动态页面 , 并且可以带参数。各个文件分别先编译，然后组合成一个文件。 （2）静态 INCLUDE 用 include 伪码实现 , 但不会检查所含文件的变化 , 适用于包含静态页面 &lt;%@ include file=&quot;included.htm&quot; %&gt; 先将文件的代码被原封不动地加入到了主页面从而合成一个文件，然后再进行编译，此时不允许有相同的变量。 （3）区别： include两种用法主要有两个方面的不同： 1）执行时间上: &lt;%@ include file=&quot;relativeURI&quot;%&gt; 是在翻译阶段执行 &lt;jsp:include page=&quot;relativeURI&quot; flush=&quot;true&quot; /&gt; 在请求处理阶段执行 2）引入内容的不同: &lt;%@ include file=&quot;relativeURI&quot;%&gt;引入静态文本 (html,jsp), 在 JSP 页面被转化成 servlet 之前和它融和到一起 &lt;jsp:include page=&quot;relativeURI&quot; flush=&quot;true&quot; /&gt; 引入执行页面或 servlet 所生成的应答文本]]></content>
      <categories>
        <category>我的错题库</category>
        <category>牛客错题整理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[易错点-框架+其他]]></title>
    <url>%2F2019%2F08%2F29%2F%E6%98%93%E9%94%99%E7%82%B9-%E6%A1%86%E6%9E%B6-%E5%85%B6%E4%BB%96%2F</url>
    <content type="text"><![CDATA[框架；其他暂未分类的题目 框架1 Spring （1）Spring并没有为我们提供日志系统，我们需要使用AOP（面向方面编程）的方式，借助Spring与日志系统log4j实现我们自己的日志系统。 （2）Spring是一系列轻量级Java EE框架的集合 （3）Spring中包含一个“依赖注入”模式的实现 （4）使用Spring可以实现声明式事务 2 判断：使用mvc模式设计的web应用程序可以大大减少代码量（×） 解析：MVC只是将分管不同功能的逻辑代码进行了隔离，增强了可维护和可扩展性，增强代码复用性，因此可以减少代码重复。 但是不保证减少代码量，多层次的调用模式还有可能增加代码量 3 依赖注入（DI）设计模式 （1）依赖注入是一种思想，或者说是一种设计模式，在java中是通过反射机制实现，与具体框架无关 （2）Spring依赖注入（DI）的三种方式，分别为：接口注入、Setter 方法注入、构造方法注入 4 在Struts框架中如果要使用Validation作验证的话，需要使用DynaValidatorActionForm 5 关于struts框架判断 （1）Struts中无法完成上传功能 （×） （2）Struts框架基于MVC模式 （√） （3）Struts框架容易引起流程复杂、结构不清晰等问题 （×） （4）Struts可以有效地降低项目的类文件数目 （×） 其他JVM1 环境变量可在编译source code时指定 2 JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的 3 java object默认的基本方法中没有copy()，含有如下方法： getClass(), hashCode(), equals(), clone(), toString(), notify(), notifyAll(),wait(), finalize() 4 Java类加载器 （1）Bootstrap：一般用本地代码实现，负责加载 JVM 基础核心类库（ rt.jar ） （2）Extension：从 java.ext.dirs 系统属性所指定的目录中加载类库，它的父加载器是 Bootstrap （3）system class loader：又叫应用类加载器，其父类是 Extension 。它是应用最广泛的类加载器。它从环境变量 classpath或者系统属性 java.class.path 所指定的目录中加载类，是用户自定义加载器的默认父加载器 （4）用户自定义类加载器：java.lang.ClassLoader 的子类 5 判断：javac一次可同时编译数个Java源文件 （√） 6 判断：一个文件中只能有一个public class （×） 解析： 一个文件中，可以有多个public class。外部类为public，还可以有public的内部类 7 判断：若类中只含一个main方法，则必须是public的 （×） 解析：类中，可以有main方法，也可以没有main方法。而有一个main()方法的时候，也可以是任意访问权限，因为这个类不一定要执行，可以只是辅助类 8 判断：javac.exe能指定编译结果要置于哪个目录（directory） （√） 解析：－s指定存放生成的源文件的位置 9 java调试器jdb.exe 10 判断：如果一个源文件中有多个类，那么构造器必须与公共类同名（×） 解析：如果有多个类，那么每个类都可以有自己的构造器，构造器与所属的类同名即可 11 一个Java源程序文件中定义几个类和接口，则编译该文件后生成几个以.class为后缀的字节码文件 数据库1 DBMS：数据库管理系统(Database Management System) DBMS是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，简称DBMS （1）DBMS对数据库的保护通过4个方面来实现： 数据库的恢复 数据库的并发控制 数据库的完整性控制 数据库安全性控制 （2） DBMS中事务有四个特性：持久性，一致性，原子性，隔离性 持久性实现——恢复管理子系统 一致性实现——并发控制子系统 原子性实现——完整性管理子系统 隔离性实现——安全控制管理子系统 2 JDBC statement （1）Statement、PreparedStatement和CallableStatement都是接口(interface) （2）Statement继承自Wrapper、PreparedStatement继承自Statement、CallableStatement继承自PreparedStatement （3）Statement接口提供了执行语句和获取结果的基本方法； PreparedStatement接口添加了处理 IN 参数的方法； CallableStatement接口添加了处理 OUT 参数的方法 （4）PreparedStatement的占位符对应着即将与之对应当值，并且一个占位符只能对应一个值 CallableStatement:支持调用存储过程,提供了对输入/输出参数(INOUT)的支持 图形化1 Swing与AWT （1）Swing 为解决 AWT 存在的问题而新开发的图形界面包。Swing是对AWT的改良和扩展。Swing由纯Java写成，可移植性好，外观在不同平台上相同。 Swing是AWT的子类（×） Swing在不同的操作系统中显示相同的风格（√） （2）AWT AWT抽象窗口工具包，早期编写图形界面应用程序的包。是通过调用操作系统的native方法实现的，所以不同的操作系统有不同的外观风格。 AWT在不同操作系统中显示相同的风格（×） AWT不支持事件类型，Swing支持事件模型（×） 2 判断：JPanel中不能包含按钮 （×） #1 软件系统测试的16个策略 系统测试的16个策略：功能测试，性能测试（负载测试），压力测试，容量测试，安全性测试，GUI测试（易用性测试）， 可用性测试，安装测试，配置测试，异常测试，备份测试，健壮性测试，文档测试，在线帮助测试，网络测试，稳定性测试 2 在Applet中： （1）init()：初始化； （2）start()：激活； （3）stop()：当Applet被覆盖时，可用stop()方法停止线程，典型作用是挂起一个线程；（applet 程序的页面最小化时执行的语句） （4）destroy()：终止Applet,释放Applet的所有资源 3 （1）实现GBK编码字节流到UTF-8编码字节流的转换： byte[] src,dst; dst=new String(src，&quot;GBK&quot;).getBytes(&quot;UTF-8&quot;); （2）java中将ISO8859-1字符串转成GB2312编码：new String(&quot;ISO8959-1&quot;.getBytes(&quot;ISO8959-1&quot;)，“GB2312”) 4 判断：每个中文字符占用2个字节，每个英文字符占用1个字节（×） 解析：Java一律采用Unicode编码方式，每个字符无论中文还是英文字符都占用2个字节 5 判断：Java的char类型，通常以UTF-16 Big Endian的方式保存一个字符（√） 6 JMX是在JDK1.4开始支持的 7 效率最高的复制方法：System.arraycopy() 8 面向对象的五大基本原则： 单一职责原则（SRP） 开放封闭原则（OCP） 里氏替换原则（LSP） 依赖倒置原则（DIP） 接口隔离原则（ISP） 9 依赖注入目的是减少组件之间的耦合度，使开发变得简单 10 int i = 0; i=i++; //执行赋值操作之后再++ System.out.println(i); /*返回值为0 若执行i++则返回1 若执行i=++i则返回1*/ 11 中间件：中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源。中间件位于客户机/服务器的操作系统之上，管理计算机资源和网络通讯 判断：中间件运行于客户机/服务器的操作系统内核中，提高内核运行效率 （×） 解析：中间件并不能提高内核的效率，一般只是负责网络信息的分发处理 12 判断：finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源的回收，例如关闭文件等 （×） 解析：finalize()方法用于在垃圾回收器将对象从内存中清理出去之前，做必要的清理工作（整理系统资源、执行其他清理工作）。但是finalize()方法不一定被JVM调用，只有当垃圾回收器要清除垃圾时才被调用 13 判断：java语言中的方法必定属于某一类 （×） 解析：方法也可以属于接口 14 @SuppressWarnings(“deprecation”)的功能是：屏蔽不赞同使用的类和方法的警告 15 判断：假设数据库中的字符是以GBK编码的，那么显示数据库数据的网页也必须是GBK编码的 （×） 解析：不同的编码之间是可以转换的 16 判断：str+=&apos; a&apos; （×） 解析：有空格是字符串，需要用双引号 17 java线程类优先级相同 （×） 18 编码---判断： （1）ASCII码是ANSI码的子集 （√） （2）在简体中文的Windows系统中，ANSI就是GB2312 （√） （3）ASCII码都是可打印字符 （×） 解析：ASCII还包含空字符 19 路径的表示 （1） ./——表示当前项目的路径 （2） ../——表示当前目录的父目录路径 （3）盘符：/name/file——表示物理路径 20 null可以被强制类型转换成任意类型（不是任意类型对象），于是可以通过它来执行静态方法 21 private float f=1.0; //编译错误（大类型——&gt;小类型，需要进行强制转换 private float f=1.0f;/ private float f=float(1.0);） 22 Java事件处理模型：事件源、事件对象、事件监听器 23 Log4j的日志打印级别可以在运行时重新设置 （×） 24 Java程序的种类： （a）内嵌于Web文件中，由浏览器来观看的_Applet （b）可独立运行的 Application （c）服务器端的 Servlets 25 java和C++都有三个特征：封装、继承和多态 26 int count = 0; count=count++; //这种赋值没有意义，count++先赋值，再自加，所以count值永远是0]]></content>
      <categories>
        <category>我的错题库</category>
        <category>牛客错题整理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[易错点-多线程+常用对象API]]></title>
    <url>%2F2019%2F08%2F29%2F%E6%98%93%E9%94%99%E7%82%B9-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B8%B8%E7%94%A8%E5%AF%B9%E8%B1%A1API%2F</url>
    <content type="text"><![CDATA[多线程；String类、StringBuffer类、StringBuilder类；数组；基本数据类型包装类；集合类；其他对象API（System类、Runtime类、Math类、Date类、Calendar类） 多线程创建并启动线程的过程为：定义线程——&gt;实例化线程——&gt;启动线程 定义线程：（1）扩展java.lang.Thread类（2）实现java.lang.Runnable接口 实例化线程：（1）如果是扩展java.lang.Thread类的线程，则直接new即可。（2）如果是实现了java.lang.Runnable接口的类，则用Thread的构造方法： Thread(Runnable target) eg: new Thread(new MyRunnable()).start() Thread(Runnable target, String name) Thread(ThreadGroup group, Runnable target) Thread(ThreadGroup group, Runnable target, String name) Thread(ThreadGroup group, Runnable target, String name, long stackSize) 启动线程：在线程的Thread对象上调用start()方法，而不是run()或者别的方法 1 run()方法用来执行线程体中具体的内容 start()方法用来启动线程对象，使其进入就绪状态 sleep()方法用来使线程进入睡眠状态 suspend()方法用来使线程挂起，要通过resume()方法使其重新启动 2 线程停止的三种方式 （1）调用stop() （2）异常抛出 （3）线程执行完毕 3 锁：函数使用的锁是this(即对象本身)，若函数被static修饰则锁为 类名.class 4 ConcurrentHashMap使用ReentrantLock来保证线程安全。 （1）hashMap在单线程中使用大大提高效率，在多线程的情况下使用hashTable来确保安全。 （2）hashTable中使用synchronized关键字来实现安全机制，但是synchronized是对整张hash表 进行锁定即让线程独享整张hash表，在安全同时造成了浪费。 （3）concurrentHashMap采用分段加锁的机制来确保安全 5 Java并发 （1）CopyOnWriteArrayList适合使用在读操作远远大于写操作的场景里，比如缓存。 （2）ReadWriteLock当写操作时，其他线程无法读取或写入数据， 而当读操作时，其它线程无法写入数据，但却可以读取数据 。适用于读取远远大于写入的操作。 （3）ConcurrentHashMap是一个线程安全的HashMap，它的主要功能是提供了一组和HashMap 功能相同但是线程安全的方法。ConcurrentHashMap可以做到读取数据不加锁，不用对整个ConcurrentHashMap加锁 6 线程调度算法是平台独立的 7 前台线程与后台线程 （1）jre 判断程序是否执行结束的标准是所有的前台线程执行完毕。 属于某个进程的所有前台线程都终止后，该进程就会被终止。 （2）可以在任何时候将前台线程修改为后台线程，方式是设置Thread.IsBackground 属性。 （3）不管是前台线程还是后台线程，如果线程内出现了异常，都会导致进程的终止。 （4）托管线程池中的线程都是后台线程，使用new Thread方式创建的线程默认都是前台线程。 说明：一般后台线程用于处理时间较短的任务，如在一个Web服务器中可以利用后台线程来处理客户端发过来的请求信息。 而前台线程一般用于处理需要长时间等待的任务，如在Web服务器中的监听客户端请求的程序，或是定时对某些系统资源进行扫描的程序 8 截止JDK1.8版本,java并发框架支持锁包括：读写锁、自旋锁、乐观锁 9 同步器是一些使线程能够等待另一个线程的对象，允许它们协调动作。最常用的同步器是CountDownLatch和Semaphore，不常用的是Barrier 和Exchanger 10 ThreadLocal （1）ThreadLocal用于创建线程的本地变量，该变量是线程之间不共享的 （2）ThreadLocal是采用哈希表的方式来为每个线程都提供一个变量的副本 （3）ThreadLocal保证各个线程间数据安全，每个线程的数据不会被另外线程访问和破坏 ThreadLocal的作用是提供线程内的局部变量（类似于private static的作用，但是多个线程之间数据又不共享），这种变量在线程的生命周期内起作用， 减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度 String类、StringBuffer类、StringBuilder类1 string是值传递，stringbuffer是引用传递 2 String a=&quot;Hello&quot;; String b=a.substring(0,2); //b的值为He，substring( )方法截取的字符串“左闭右开” 3 String类默认是final类型的，不能继承和修改这个类（String属于值传递） 4 String s =new String(“xyz”);创建了几个string object？ 答：两个， 第一个在堆中，第二个在字符串常量池中！如果在Java字符串常量池中已经存在，就只会创建一个 数组1 判断：int a[][]=new int[][] （×） 解析：二维数组的声明必须指定第一个维度的初始值 2 在java 中，声明一个数组时，不能直接限定数组长度，只有在创建实例化对象时，才能对给定数组长度 3 判断：Java实现了真数组，避免了覆盖数据类型的可能 （×） 解析：Java实现了真数组，避免了数据覆盖的可能，而不是数据覆盖类型 基本数据类型包装类1 ==和.equals()运算 （1）基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较 （2） 两个Integer类型（不是new出来的）进行“==”比较，如果其值在-128至127，那么返回true，否则（会new对象，然后比较地址值）返回false （3） 两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true （4） 基本型封装类型调用equals()，但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行（3）中的比较 2 可以把任何一种数据类型的变量赋给Object类型的变量。其中，基本数据类型会自动装箱 3 Java中的byte，short，char进行计算时都会先提升为int类型 注意：没有final修饰的变量相加后，才会被自动提升为int型； 而被fianl修饰的变量不会自动改变类型，当两个final修饰的变量相操作时，结果会根据左边变量的类型而转化 4 instanceof：可以用来判断某个实例变量是否属于某种类的类型，还可以判断某个类是否属于某个类的子类的类型 集合类集合框架、Collection、IteratorList List集合有序（添加顺序）且可重复 List继承自Collection接口，List也是一个接口。 ArrayList、LinkedList、Vector类实现了List接口。用的时候一般都用ArrayList ArrayList、LinkedList的选择：（1）对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList要移动指针；对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据（2）当操作是在一列数据的后面添加数据而不是在前面或中间，并且需要随机地访问其中的元素时，使用ArrayList会提供比较好的性能；当你的操作是在一列数据的前面或中间添加或删除数据，并且按照顺序访问其中的元素时，就应该使用LinkedList了 ArrayList是实现List接口的大小可变数组ArrayList删除元素后，剩余元素会依次向前移动，因此下标一直在变，size()也会减小 Set List一定有序，Set不一定无序我们经常听说List是有序且重复的，Set是无序不重复的。这里有个误区，这里说的顺序有两个概念，一是按添加的顺序排列，二是按自然顺序a-z排列。Set并不是无序的，传统说法中的Set无序是指HashSet,它不能保证元素的添加顺序，更不能保证自然顺序。而Set的其他实现类是可以实现这两种顺序的（TreeSet可以实现自然顺序有序，LinkedHashSet可以实现添加顺序有序） AbstractSet类实现了Set接口HashSet继承了AbstractSet类，所以相当于也实现了Set接口（Java中子类会继承父类对于接口的实现） ResultSet跟普通的数组不同，索引从1开始而不是从0开始 Map1 key-value对，键值对，相同键值会放在一处，后一个会覆盖前一个的数值 2 HashMap可以插入null的key或value 插入的时候，检查是否已经存在相同的key，如果不存在，则直接插入； 如果存在，则用新的value替换旧的value 3 在Java中，HashMap中是用链地址法来解决哈希冲突的 4 判断：HashTable使用Enumeration，HashMap使用Iterator （√） 解析：Hashtable、HashMap都使用了Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 5 判断：Hashtable直接使用对象的hashCode，HashMap重新计算hash值，而且用与代替求模 （√） 泛型集合框架工具类（Collections、Arrays）1 Arrays.asList() （1）将一个数组转化为一个List对象，这个方法会返回一个ArrayList类型的对象 但这个ArrayList类并非java.util.ArrayList类，而是Arrays类的静态内部类！ （2）用这个对象对列表进行添加删除更新操作，就会报UnsupportedOperationException异常 其他对象APISystem类1 判断：我们在程序中经常使用“System.out.println()”来输出信息，语句中的System是包名，out是类名，println是方法名 （×） 解析：System是java.lang中的一个类，out是System内的一个成员变量， 这个变量是一个java.io.PrintStream类的对象，println()是它的一个方法 Runtime类Number类1 Number类可以被继承，Integer，Float，Double等都继承自Number类 Math类1 ceil()/floor() （1）Math.ceil(d1) //如果参数小于0且大于-1.0，结果为-0 （2）Math.floor(d1) //如果参数是无穷、正0、负0，那么结果与参数相同（如果是-0.0，那么其结果是-0.0） Date类Calendar类]]></content>
      <categories>
        <category>我的错题库</category>
        <category>牛客错题整理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[易错点-Java核心概念]]></title>
    <url>%2F2019%2F08%2F29%2F%E6%98%93%E9%94%99%E7%82%B9-Java%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[变量与常量；运算符；构造方法与一般（成员）方法；成员变量与静态变量；成员变量与局部变量；静态块、构造块、执行顺序优先级；关键字；继承、实现；抽象类、接口；重载、重写；多态；内部类；异常；包、权限；内存管理 变量与常量；运算符区分变量、常量、形参变量是一个引用，常量代表一个数值，形参只是一个标识。 1 变量有它对应的地址和值，需要为它开辟内存空间 变量存在于堆或栈中 2 常量存在于常量池中，在类加载之前就已经被加载，且不会改变 实际应用中，常量常用来配置文件路径 3 形参只是一个标识符号，用来传递实参 运算符1 运算符优先级 括号&gt; 单元操作符&gt; 算术运算符&gt; 移位操作符&gt; 关系运算符&gt; 位运算符&gt; 逻辑运算符&gt; 三元操作符&gt; 赋值运算符 2 区分&amp;和&amp;&amp; &amp;在逻辑运算中是非短路逻辑与，在位运算中是按位与 &amp;&amp;在逻辑运算中是 逻辑与、短路 3 区分|与|| 用法：condition 1 | condition 2、condition 1 ||condition 2 &quot;|&quot;是按位或：先判断条件1，不管条件1是否可以决定结果（这里决定结果为true)，都会执行条件2 &quot;||&quot;是逻辑或：先判断条件1，如果条件1可以决定结果（这里决定结果为true)，那么就不会执行条件2 4 计算机用补码存储数据 -n=~n+1 5 &lt;&lt;表示左移位 &gt;&gt;表示带符号右移位 &gt;&gt;&gt;表示无符号右移 但是没有&lt;&lt;&lt;运算符 6 int a = 2, b = 0; do { --b; } while (a --&gt; 0);//判断循环结束后a/b的值 由于判断条件中--在后因此先做判断再-- 第一次进入do中b变为-1，此时a=2判断大于0为真，然后a--变为1 第二次进入do中b变为-2，此时a=1判断大于0为真，然后a--变为0 第三次进入do中b变为-3，此时a=0判断大于0为假，跳出while 7 if (flag = true) //这是一个赋值运算，而不是判断是否相等。返回值为true 一对方法、两对变量构造方法和成员方法 构造方法：①对象创建时自动调用，对该对象进行初始化；②只调用一次；③没有返回值；④构造器中的this()指向同一个类中重载的另一个构造器。 成员方法：①对象创建后，需要主动调用；②可以调用多次；③必须有返回值；④方法中引用this指向该方法所属类的对象。 1 判断：构造方法只能通过new自动调用（×） 解析：构造方法可以通过反射自动调用 2 如果父类中只有有参构造函数，没有无参构造函数，则子类构造函数必须显式调用 3 判断：如果子类只有一个有参构造函数，那么必然会调用父类中相同参数的构造函数 解析：可以调用父类无参的构造函数，子类的有参构造函数和是否调用父类的有参数的构造函数无必然联系 成员/实例变量与静态变量/类变量 二者生命周期不同：成员变量依存于对象，静态变量依存于类 数据存储位置不同：成员变量存储于堆中，静态变量存储于方法区中 调用方式不同：成员变量需要先创建对象，再通过“对象.成员变量”来调用，静态变量直接用类名调用 1 关于变量初始化 无论是类变量还是实例变量，在使用前都是非空的。而局部变量没有初始化过程，在使用前必须赋值 2 Java中静态变量只能在类主体中定义，不能在方法中定义；因为静态变量属于类所有而不属于方法 3 判断代码结果： public class Test { public int x; public static void main(String []args) { System. out. println(&quot;Value is&quot; + x); //错误，非静态变量不能直接被静态方法引用。 //可以先创建Test类的对象，用对象调用非静态变量。 成员/实例变量与局部变量局部变量作用在方法或区域代码块中 1 局部变量必须初始化 2 局部变量不能用static修饰 3 静态代码块中的变量为局部变量 4 java采用局部优先的思想； 局部变量可以和成员变量相同，使用标识符调用时，优先使用局部变量 静态块、构造块、执行顺序优先级 静态代码块：给类初始化，JVM加载类时执行，仅执行一次。 构造代码块：给所有对象初始化，每一次创建对象时执行（有通用性） 构造函数：给对应的对象初始化（有针对性），随着类的加载而加载进内存，但不执行（区分执行和加载） 执行顺序优先级：【静态块=静态成员变量】&gt;main()&gt;【构造块=普通成员变量&gt;构造方法】且前后两个区域，父类优先级&gt;子类优先级 关键字Java所有关键字、保留字 1 静态方法（包括main方法）中不能有this，因为静态方法属于类而不属于某个对象，this指代当前对象 2 static不能修饰局部变量，被static修饰的变量称为静态变量，静态变量属于整个类，而局部变量属于方法，只在该方法内有效 3 声明为static和transient类型的成员数据不能被串行化/序列化。因为static代表类的状态，transient代表对象的临时数据 4 volatile关键字：用于限定变量只能从内存中读取，保证对于所有线程而言，值都是一致的。但volatile不能保证线程安全。 判断：对volatile变量的操作不会造成阻塞 （√） 对volatile变量的操作是原子性的 （×） 不依赖其他锁机制，多线程环境下的计数器可用volatile实现 （×） 5 判断：This调用语句必须是构造函数中的第一个可执行语句（×） 解析：this()（调用无参构造方法）才必须是构造函数中的第一个可执行语句，用this调用语句（即this.）并不需要 6 为什么super( )和this( )不能同时出现在同一个构造函数中？ 答：任何的子类都必须要先调用父类的构造函数， 而当你采用“显示构造方法调用”即用this(...)调用当前类的其他构造函数时，这个时候父类的构造就在this(...)里面执行了， this(...)里面应该不仅包括当前类的构造，还必须包括父类的构造。 7 一个类只要实现了Serilizable接口，这个类的所有属性和方法都会自动序列化； 这个类的有些属性需要序列化，而其他属性不需要被序列化； 其中不需要序列化的属性和方法用 transient关键字标记 8 final类型的变量一定要初始化，因为final的变量不可更改 9 判断：引用变量被final修饰之后，不能再指向其他对象，它指向的对象的内容也是不可变的 （×） 解析：使用 final 关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的 10 synchronized很强大，既可以保证可见性，又可以保证原子性，而volatile不能保证原子性 11 switch case语句 （1）在Java7之前，switch只能支持 byte、short、char、int或者其对应的封装类以及Enum类型，不能是float，double和boolean类型。String类型是java7开始支持。 （2）在switch语句中，表达式的值不能是null，否则会在运行时抛出NullPointerException。 （3）在case字句中也不能使用null，否则会出现编译错误。同时，case字句的值是不能重复的 12 形参的修饰符 对于形式参数只能用final修饰符，其它任何修饰符都会引起编译器错误 但是用这个修饰符也有一定的限制，就是在方法中不能对参数做任何修改 不过一般情况下，一个方法的形参不用final修饰。只有在特殊情况下——也就是：方法内部类。 一个方法内的内部类如果使用了这个方法的参数或者局部变量的话，这个参数或局部变量应该是final 继承、实现1 判断：（1）子类可以继承父类的构造函数（×） 解析：子类不可以继承父类的构造函数，只是调用父类构造函数（系统默认调用父类无参构造函数super();） （2）子类可以继承父类中的私有成员变量（√） 解析：无论父类中的成员变量是私有的、共有的、还是其它类型的，子类都会拥有父类中的这些成员变量。 但是父类中的私有成员变量，无法在子类中直接访问，必须通过从父类中继承得到的protected、public方法 （如getter、setter方法）来访问。 2 先继承，再实现，否则编译报错 3 判断：优先选用接口，尽量少用抽象类 （√） 解析： 继承的耦合性太强，java推荐高内聚低耦合的设计思路，不推荐使用继承 抽象类、接口 抽象类中可以有构造方法，接口中不能有构造方法，也不能实例化接口的对象 抽象类中可以包含静态方法，接口中不能包含静态方法（JDK1.8之前） 抽象类和接口中都可以包含静态成员变量；抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型 抽象类中可以有普通成员变量/成员方法，接口中不能有（JDK1.8之前） JDK1.8之后，接口可以有default、static方法，而不只有抽象方法 判断：抽象类自身可以定义成员而接口不可以（×）解析：1.8之后接口允许定义default成员变量/方法 接口中可以不声明任何方法和成员变量；抽象类可以不包含抽象方法，但有抽象方法的类一定要声明为抽象类。 抽象类和接口中方法的默认访问权限：关于抽象类JDK 1.8 以前，抽象类的方法默认访问权限为protectedJDK 1.8 时，抽象类的方法默认访问权限变为default关于接口JDK 1.8 以前，接口中的方法必须是public的JDK 1.8 时，接口中的方法可以是public的，也可以是default的 重载、重写 重载：在同一个类中①方法名相同，参数列表不同②与方法的返回值无关，与权限修饰符无关 重写：在子父类中遵循“两同两小一大”的规则：①两同：方法名相同，形参列表相同②两小：子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等③一大：子类方法的访问权限应比父类方法的访问权限更大或相等 子类重写父类方法时，方法的访问权限不能小于原访问权限。在接口中，方法的默认权限是public，那么子类重写后权限只能是public java中可以有多个重载的main方法，只有public static void main(String[] args){}是函数入口 多态1 call by value（值传递）不会改变实际参数的数值 call by reference（引用传递）不会改变实际参数的地址，但是可以改变实际参数的内容 2 判断：多态性意味着一个操作在不同的类中可以有不同的实现方式（√） 内部类 局部内部类：定义在一个方法或者一个作用域和成员内部类的区别在于：局部内部类的访问仅限于方法内或者该作用域内 成员内部类：定义在类中（1）成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。（2）成员内部类中的成员与外部类中的成员重名，默认情况下访问的是内部类的成员。（3）其他外部类访问成员内部类，需要先创建内部类的对象才能访问其中的成员。 //别人访问它（4）成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象 匿名内部类：（1）匿名内部类用得最多，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。（2）匿名内部类用法与局部内部类不一致，首先从定义上就不一样，匿名类用在任何允许存在表达式的地方，而局部内部类用于在任何允许出现局部变量的地方出现。 匿名类只能使用一次，而局部类则可以在自己的定义域内多次使用。（3）匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调 静态内部类：（1）静态内部类是不需要依赖于外部类的，相当于另外一个外部类。这点和类的静态成员属性有点类似，并且它不能直接使用外部类的非static成员变量或者方法（需要先创建外部类的对象）//它访问别人 1 判断：包含在java文件里的公共类必须与文件的名字相同（×） 解析：公共的内部类不需要和文件同名 2 判断 （1）对于局部内部类，只有在方法的局部变量被标记为final或局部变量是effctively final的，内部类才能使用它们 （√） （2）成员内部类位于外部类内部，可以直接调用外部类的所有方法（静态方法和非静态方法） （√） （3）由于匿名内部类只能用在方法内部，所以匿名内部类的用法与局部内部类是一致的 （×） （4）静态内部类可以访问外部类的成员变量 （×） （5）静态内部类不可以直接访问外围类的非静态数据，而非静态内部类可以直接访问外围类的数据，包括私有数据 （√） 3 匿名内部类： （1）匿名内部类的创建格式为： new 父类构造器（参数列表）|实现接口（）{ //匿名内部类的类体实现 } （2）使用匿名内部类时，必须继承一个类或实现一个接口 （3）匿名内部类由于没有名字，因此不能定义构造函数 （4）匿名内部类中不能含有静态成员变量和静态方法 异常1 判断：在有除法存在的代码处，为了防止分母为零，必须抛出并捕获异常（×） 解析：分母为0 为运行时异常，jvm帮我们捕获，无需代码里面显式捕获 2 判断：在有除法存在的代码处，抛不抛出异常均可 （√） 解析：除数为0 等ArithmeticException，是RuntimException的子类。而运行时异常将由运行时系统自动抛出， 不需要使用throw语句。Java编译器允许忽略运行时异常，一个方法可以既不捕捉，也不声明抛出运行时异常 3 FileNotFoundException属于编译时异常，需要处理 4 判断：catch块和finally块可以同时省略 （×） 解析：假如try中有异常抛出，则会去执行catch块，再去执行finally块；假如没有catch块，可以直接执行finally块， 方法就以抛出异常的方式结束，而finally后的内容也不会被执行，所以catch 和finally不能同时省略 5 若catch中的参数类型有父类子类关系，此时应该将父类放在后面，子类放在前面 6 catch捕获到异常后程序结束 7 finally{}代码块总是比return先执行（除非finally代码块中也有return语句） 8 （1）finally是在return后面的表达式运算后执行的（返回值已经确定） （2）finally语句块在 catch语句块中的return语句之前执行 （3）确定返回值——&gt;执行finally语句——&gt;执行catch语句块中的return语句 （4）如果finally语句块中有return会使程序提前结束，不再返回catch中的return语句的结果 9 wait()方法要以try/catch包覆，或是掷出InterruptedException才行 包、权限权限 包的权限（1）default修饰符，可以被同一包中所有类访问（2）protected修饰符，可以被同一包中所有类访问，被修饰的类也可以作为父类被所有子类访问 Java中类与成员的访问权限共有四种：public，private，protected，还包括default（1）对于外部类来说，只有两种修饰，public和默认（default），因为外部类放在包中，只有两种可能，包可见和包不可见。（2）对于内部类来说，可以有所有的修饰，因为内部类放在外部类中，与成员变量的地位一致，所以有四种可能 类访问控制符有三种：public ，private， protected 1 在子类中不能访问父类的private字段，否则编译不通过 2 判断：实例方法可直接调用超类的实例方法 （×） 解析：实例方法可以调用超类公有实例方法 包 常用Java包java.awt：包含构成抽象窗口工具集的多个类，用来构建和管理应用程序的图形用户界面java.lang：提供java编成语言的程序设计的基础类java.io：包含提供多种输出输入功能的类，java.net：包含执行与网络有关的类，如URL，SCOKET，SEVERSOCKET，java.applet：包含java小应用程序的类java.util：包含一些实用性的类 1 判断：静态内部类不可以直接访问外围类的非静态数据，而非静态内部类可以直接访问外围类的数据，包括私有数据 （√） 2 有一个源代码，只包含import java.util.* ; 这一个import语句，能访问java/util目录下的所有类，不能访问java/util子目录下的所有类 3 package语句必须作为源文件的第一条非注释性语句，一个源文件只能指定一个包，只能包含一条package语句 内存管理 JDK1.6提供的6种作用于不同年代的垃圾收集器 年轻代的GC 叫 young GC ，有时候也叫 minor GC 。年老代或者永久代的 GC ，叫 full GC ，也叫 major GC（1）新生代：1）所有对象创建在新生代的Eden区，当Eden区满后触发新生代的Minor GC，将Eden区和非空闲Survivor区存活的对象复制到另外一个空闲的Survivor区中。2）保证一个Survivor区是空的，新生代Minor GC就是在两个Survivor区之间相互复制存活对象，直到Survivor区满为止。（2）老年代：当Survivor区也满了之后就通过Minor GC将对象复制到老年代。老年代也满了的话，就将触发Full GC，针对整个堆（包括新生代、老年代、持久代）进行垃圾回收。（3）持久代：持久代如果满了，将触发Full GC一则形象的小故事帮你理解： 堆内存：（1）java的堆内存分为两块:permantspace（持久带） 和 heap space（2）持久带中主要存放静态类型数据，如Java Class, Method 等， 与垃圾收集器要收集的Java对象关系不大。（3）heapspace分为年轻带和年老带 。年轻代的垃圾回收叫 Young GC， 年老代的垃圾回收叫 Full GC。（4）年老代溢出原因： 循环上万次的字符串处理、创建上千万个对象、在一段代码内申请上百M甚至上G的内存（5） 持久代溢出原因：动态加载了大量Java类而导致溢出 1 jvm中垃圾回收分为scanvenge gc和full GC，其中full GC触发的条件可能有哪些？ 答：老年代满、持久代满、System.gc() 2 String str2=str1.substring(5); //substring()方法实际上是new了对象存在堆中，而不是将返回的字符串存在常量池中，常量池是PermGen的 3 判断：在Java中，对于不再使用的内存资源，如调用完成的方法，“垃圾回收器”会自动将其释放（×） 解析：方法调用时，会创建栈帧在栈中，调用完是程序自动出栈释放，而不是gc释放 4 方法区和堆是被线程共享的区域；在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。 方法区和堆内存是线程共享的；程序计数器、虚拟机栈是线程隔离的 5 （1）jvm堆分为：新生代（一般是一个Eden区，两个Survivor区），老年代（old区）。常量池属于 PermGen（方法区） （2） java7，字符串常量池从方法区移到堆中。java8 整个常量池从方法区中移除。方法区使用元空间（MetaSpace）实现 6 两个最基本的jvm的垃圾回收算法：复制算法、标记算法 新生代基本采用复制算法，老年代采用标记整理算法，cms采用标记清理 7 Heap空间（不包括PermGen）保留的字符数为new对象所占的空间。PermGen 中是常量所占的空间 8 判断：垃圾回收机制保证了JAVA程序不会出现内存溢出 （×） 解析：垃圾回收机制只是回收不再使用的JVM内存，如果程序有严重BUG，照样内存溢出]]></content>
      <categories>
        <category>我的错题库</category>
        <category>牛客错题整理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[操作系统（四）]]></title>
    <url>%2F2019%2F08%2F29%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Miracles sometimes occur, but one has to work terribly for them. ——C. Weizmann 存储器管理 存储器的层次结构存储器至少有三级：最高层是CPU寄存器、中间层为主存、最底层是辅存 可执行存储器：CPU寄存器+主存，操作系统存储管理的范畴 可执行存储器和辅存的访问机制不同，耗费的时间也不同 存储器管理的内容操作系统对可执行存储器进行分配、回收、在各个存储层次间进行数据移动 主存储器与寄存器 主存储器（内存、主存）保存进程运行时的程序和数据由于主存储器的访问速度远低于CPU执行指令的速度，故引入了寄存器和高速缓存 寄存器访问速度最快，完全能与CPU协调工作 高速缓存和磁盘缓存 高速缓存介于内存和寄存器之间，容量（几十KB到几MB）大于寄存器，访问速度快于内存 磁盘缓存介于内存和磁盘之间，利用内存空间，来暂存磁盘中读出/写入的信息。主存可以看成是辅存的高速缓存 程序的装入和链接 用户程序要运行，必须要为之创建进程（分配内存资源、申请并初始化PCB）创建进程的第一步，将程序和数据装入内存 对用户程序的处理步骤（1）编译：编译程序将用户代码编译成若干个目标模块（2）链接：链接程序将一组目标模块和所需要的库函数链接在一起，形成一个完整的装入模块（3）装入：装入程序将装入模块装入内存 连续分配方式连续分配方式：一个用户程序分配一个连续的内存空间分类：单一连续分配、固定分区分配、动态分区分配、动态重定位分区分配 单一连续分配 只能用于单用户、单任务的OS中 软件简单，硬件要求低，无需采取存储保护措施 固定分区分配 将内存空间划分为若干个固定大小的区域，每个分区只装入一个进程 将分区按大小排队，建立一张分区使用表 用于60年代的IBM360的MFT操作系统 动态分区分配 根据进程的实际需要，动态地为之分配内存空间 数据结构：空闲分区表、空闲分区链 动态分区分配算法：首次适应算法、循环首次适应算法、最佳适应算法、最坏适应算法、快速适应算法 分区分配操作：分配内存、回收内存 对换对换：把内存中暂时不能运行的进程或者暂时不用的程序和数据调出到外存上，腾出内存空间，再把已具备运行条件的进程或所需要的程序和数据调入内存 基本分页存储管理方式离散分配内存方式：允许将一个进程分散装入到不相邻的分区中（提高内存利用率）分类：按离散分配的基本单位，分为分页存储管理方式、分段存储管理方式 分页存储管理（1）将一个进程的逻辑地址空间分成若干个大小相等的片，称为页（2）相应地，把内存空间分成与页面大小相同的若干个存储快，称为（物理）块（3）为进程分配内存时，以块为单位将进程的若干个页分别装入不相邻的物理块中 页表系统为每个进程建立了一张页面映像表，用于找到每个页面对应的物理块（页表实现从页号到块号的地址映射） 地址变换机构（1）作用：将逻辑地址中的页号，转换为内存中的物理块号（2）地址变换依靠页表实现：一个页表对应一个地址变换寄存器，实际中寄存器被唯一的一个页表寄存器PTR替代（3）运行时，将页表在内存中的首地址和页表长度保存到页表寄存器（4）平时，这两个参数存放在本进程的PCB中 多级页表 基本分段存储管理方式基本分段存储管理方式 目的引入分段存储管理方式主要是为了满足用户/程序员在编程和使用上多方面的要求 好处 方便编程 信息共享 信息保护 动态增长 动态链接 分段（1）进程的内存空间被划分为若干个段，每个段定义了一组逻辑信息（2）段的逻辑地址（二维）：段号+段内地址（3）分段的实现：编译程序自动分段，装入程序装入这些段，并为每个段赋予一个段号 段表系统为每个进程建立一张段映射表，记录段的首地址和段的长度（段表用于实现从逻辑段到物理内存区的映射） 段表寄存器：用于实现逻辑段号到物理地址的变换 分段与分页的区别相同点：（1）两者都采用离散分配方式 （2）都要通过地址映射机构进行地址变换 不同点：（1）页是信息的物理单位——为了实现离散分配 段是信息的逻辑单位——为了满足用户需求 （2）页的大小固定且由系统决定 段的大小由用户程序决定 （3）分页的进程地址空间是一维的，分段的进程地址空间是二维的，标识一个地址需要段号和段内地址 （4）分页系统不容易实现共享和动态链接，分段很容易 段页式存储管理方式既具有分段系统的便与实现、分段可共享、可动态连接等优点；又能像分页系统很好地解决内存的外部碎片问题；还可为各个分段离散地分配内存 原理现将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段富裕一个段名 地址结构：段号+段内页号+页内地址 段页式系统获得一条指令/数据的三次访问第一次访问：内存中的段表，得到页表首地址第二次访问：内存中的页表，得到指令/数据的物理地址（页所在的物理块号+页内地址）第三次访问：内存中的指令/数据的物理地址，取出数据 虚拟存储器虚拟存储器的引入之前的存储器管理方式都要求，将一个进程全部装入内存后才能运行针对进程会很大，或者进程数量很多，就需要扩充内存 1 虚拟内存的原理：基于局部性原理，进程运行之前，没有必要全部装入内存，仅需将当前要运行的少数页面或段先装入内存，其余部分留在磁盘上。 这样可以使一个大的进程在较小的内存中运行，从用户角度看，好像实际内存变大了 2 虚拟内存：是指具有请求调入和置换功能，能从逻辑上对内存加以扩充的一种存储器系统 实质：不用完整地将进程装入内存后才运行，先装入并执行进程的一部分段/页 3 虚拟内存都建立在离散分配的存储管理方式的基础上，因为连续分配方式需要一次性申请足够多的内存空间，就没有意义 虚拟存储器的实现方法 分页请求系统基本分页系统+请求分页功能+页面置换功能 请求分段系统基本分段系统+请求分段功能+分段置换功能 虚拟存储器的特征 多次性：进程被分成多次调入内存 对换性：进程运行中允许换进、换出 虚拟性 请求分页存储管理方式建立在基本分页基础上，为了支持虚拟存储器而增加了请求调页功能和页面置换功能 硬件支持 页表机制 缺页中断机构 地址变换机构 内存分配 确定最小物理块数：取决于计算机的硬件结构 物理块的分配策略（1）固定分配局部置换为每个进程分配固定数目的物理块（2）可变分配全局置换（易实现，空闲物理块由OS管理）先为系统中的每个进程分配一定数目的物理块，OS自身拥有一个空闲物理块队列，缺页时取出物理块分配给该进程（3）可变分配局部置换进程缺页率较高或较低时，能由OS对分配的物理块加以调整 物理块分配算法（1）平均分配（2）按比例分配（3）考虑优先权分配 调页策略 调入页面的时机（发生缺页请求）（1）预调页策略（2）请求调页策略 确定从何处调入页面 请求分页系统中的外存分为两部分，存放文件的文件区和存放对换页面的对换区。 对换区使用的是连续分配方式，文件区采用的离散分配的方式。 （1）系统拥有足够的对换区空间：可以全部从对换区调入所需页面，以提髙调页速度。 （2）系统缺少足够的对换区空间：凡不会被修改的文件都直接从文件区调入； 但对于那些可能被修改的部分，在将它们换出时须调到对换区，以后需要时再从对换区调入。 （3）UNIX方式：与进程有关的文件都放在文件区，故未运行过的页面，都应从文件区调入。 曾经运行过但又被换出的页面，由于是被放在对换区，因此下次调入时应从对换区调入。进程请求的共享页面若被其他进程调入内存，则无需再从对换区调入。 页面调入过程（1）程序要访问的页面不在内存中，向CPU发出缺页中断（2）保留CPU环境，转入中断处理程序（3）中断处理程序通过查找页表，在外存中找到该页（4）若此时内存能容纳新页，则启动磁盘I/O将所缺之页调入内存（5）若此时内存已满，则先按照某种置换算法从内存中选出一页准备换出，再调入缺页 页面置换算法 置换算法：选择换出页面的算法 置换算法的好坏直接影响到系统的性能 好的置换算法，应具有较低的页面更换频率（把较长时间不会用到的页面先换出） 最佳置换算法理想化的算法，选择以后永不使用的，或是最长时间内不再被访问的页面 先进先出（FIFO）置换算法实现简单，但与进程实际运行的规律不相适应 最近最久未使用（LRU）置换算法性能较好，实现复杂，需要硬件支持（每页配置一个寄存器或栈） Clock置换算法（LRU近似算法）（1）为每页设置一位访问位，再将内存中所有页面都通过链接指针链接成一个循环队列（2）当某页被访问时，其访问位被置1（3）访问位是0则换出该页；访问位是1则置为0，给该页驻留内存的机会 请求分段存储管理方式硬件支持 段表机制 缺段中断机构 地址变换机构 分段的共享与保护 共享段表 共享段的分配与回收 分段保护]]></content>
      <categories>
        <category>《计算机操作系统》</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统（二）]]></title>
    <url>%2F2019%2F08%2F29%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[The man who has made up his mind to win will never say “impossible”. 进程管理 进程的基本概念进程的特征 结构特征通常的程序不能并发执行，为使程序能独立运行，应为之配置一进程控制块（PCB：Process Control Block）进程实体：程序段+数据段+PCB 动态性进程的实质是进程实体的一次执行过程 并发性多个进程实体同存于内存中，且能在一段时间内同时运行 独立性传统OS中，进程实体是一个能独立运行、独立分配资源和独立接收调度的基本单位 异步性进程按各自独立、不可预知的速度向前推进 进程的状态一、三种基本状态 就绪状态 执行状态 阻塞状态导致阻塞的典型事件：请求IO，申请缓冲空间 二、挂起状态 引起挂起状态的原因： - 终端用户的请求（进程处于就绪状态，且暂不接受调度） - 父进程请求 - 符合调节的需要 - 操作系统的需要 三、创建状态和终止状态 创建状态创建进程的两个步骤： （1）为新进程创建PCB，并填写必要的管理信息 （2）把该进程转入就绪状态并插入就绪队列之中 注意： 创建状态的进程还不能被调度，因为虽然进程有了PCB，但是还未进入主存 终止状态进程终止也有两个步骤： （1）等待操作系统进行善后处理，将PCB清零，将PCB空间返还系统 （2）终止的进程在操作系统中还保留着记录，一旦其他进程完成了对终止进程记录的信息提取，操作系统正式删除该进程 四、进程状态的转换 进程的五种基本状态转换 具有挂起状态的进程状态转换 进程控制块PCB 什么是PCB为了描述和控制进程的运行，系统为每一个进程定义了一个数据结构——进程控制块，它是进程实体的一部分 PCB的作用使进程能够独立运行，并与其他进程并发执行 PCB是进程存在的唯一标志 PCB中的信息 进程标识符 内部标识符：操作系统赋予的唯一的数字标识符，方便系统使用 外部标识符：用户创建，通常由数字和字母组成，用户进程访问该进程时使用 处理机状态：用于保存处理机中各种寄存器中的信息，以便在进程中断后重新执行时，能找到断点的信息 进程调度信息 进程控制信息 PCB的组织方式 链接方式：把同一状态的PCB，用链接字链接成一个队列 索引方式：根据进程的状态建立相应的索引表 进程控制进程控制是进程管理中最基本的功能进程控制一般由OS内核中的原语（原子操作，在管态下执行）来实现 进程的创建 引起创建进程的事件 用户登录 作业调度 提供服务 应用请求 调用进程创建原语Creat()创建进程的步骤 申请空白PCB 为新进程分配资源 初始化进程控制块 将新进程插入就绪队列 进程的终止 引起进程终止的事件 正常结束：产生一个中断，通知OS进程已运行完毕 异常结束：出现错误和故障 外界干预：进程应外界请求而终止 进程的终止过程OS调用进程终止原语终止进程： 根据终止进程的标识符，找到该进程的PCB，读出该进程的状态 终止该进程的执行 终止子孙进程 将被终止进程的资源归还给父进程 将被终止进程从所在队列中移出 进程的阻塞与唤醒 进程阻塞进程无法继续执行，于是进程便通过调用阻塞原语block把自己阻塞进程阻塞是进程自身的一种主动行为 进程唤醒 进程的挂起与激活 进程同步进程同步的任务：对并发执行的诸进程在执行次序上进行协调，使程序的执行具有可再现性 同步机制——进程互斥地进入自己的临界区临界资源：进程间采用互斥方式对资源进行共享 临界区：进程中访问临界资源的那段代码 同步机制：进程互斥地进入自己的临界区 同步机制四条原则： 空闲让进 忙则等待 有限等待：保证进程在有限时间内能进入到自己的临界区 让权等待：当进程不能进入自己的临界区，应立即释放处理机 进程同步工具——信号量机制、管程（1）信号量机制 整型信号量 记录型信号量 AND型信号量 信号量集 （2）管程 管程是操作系统的资源管理模块，被请求和释放资源的进程调用 信号量的应用 实现进程互斥 实现前趋关系 进程通信进程通信：进程之间的信息交换低级通信：利用信号量机制实现进程间的数据传输（效率低、通信对用户不透明）高级进程通信：利用操作系统提供的一组通信命令实现进程之间的高效通信 高级通信机制 共享存储器系统 消息传递系统（应用最广，以格式化报文交换数据） 管道通信系统（通过共享文件pipe连接读进程和写进程来实现进程间通信） 消息传递通信的实现方法 直接通信：发送进程通过OS提供的发送命令，直接把消息发送给目标进程 间接通信：通过信箱实现通信，信箱可由OS或用户创建 私有信箱 公有信箱 共享信箱 线程线程的基本概念 线程：系统中独立运行和任务调度的基本单位。 特点：比进程更小的能独立运行的基本单位，用来提高程序并发执行的程度，使OS具有更好的并发性 线程与进程的区别（1）调度 进程是资源分配的基本单位，执行和调度的基本单位是线程（进程不再作为一个可执行的实体） （2）并发性 不仅进程可以并发执行，一个进程中的多个线程也能并发执行 （3）拥有资源 线程自己（几乎）不拥有系统资源，但可访问其隶书进程的资源 （4）系统开销 线程的创建、撤销和切换比进程的开销小得多 线程的状态线程和进程一样拥有就绪、执行、阻塞状态 线程间的同步线程同步机制 互斥锁 条件变量 信号量机制 线程的实现方式 内核支持线程（KST）（1）无论是系统进程还是用户进程，进程的创建、撤销都是在系统内核的支持下完成的（2）KST方式下，线程的创建、撤销和切换都是在系统内核的支持下完成的，在内核空间中通过线程控制块TCB对线程进行控制（3）线程切换时需要从用户态转到系统态，系统开销较大 用户级线程（ULT）仅存在于用户空间中，线程的创建、撤销和切换无需系统内核的支持（因此线程切换速度快）]]></content>
      <categories>
        <category>《计算机操作系统》</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统（三）]]></title>
    <url>%2F2019%2F08%2F29%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Our destiny offers not the cup of despair,but the chalice of opportunity. ——Richard Nixon 处理机调度与死锁 处理机调度的层次 处理机是最重要的计算机资源，在并发的系统中，需要系统能按照某种算法，动态地把处理机分配给就绪队列中的一个进程，使之执行 调度性能的好坏决定着处理机利用率 一个批处理作业需要经历三级调度：高级调度、中级调度、低级调度，每一级调度采用不同的调度方式和调度算法 高级调度/作业调度/长程调度 功能：把外存上处于后备队列的作业调入内存（批处理系统中，以作业为单位从外存调入内存） 作业：比程序更为广泛的概念，不仅包含了通常的程序和数据，还应配有一份作业说明书 作业控制块JCBJCB是作业在系统中存在的标志，控制系统对作业进行管理和调度 作业调度根据JCB中的信息，从外存的后备队列中选取作业调入内存，并为他们创建进程，分配资源；再将新创建的进程插入就绪队列，准备执行（分时系统中不存在作业调度，因为任务直接进内存处理，以实现及时交互） 低级调度/进程调度/短程调度 功能：在内存就绪队列中，选择获得处理机的进程；分派处理机给进程（分派程序）；保存处理机的现场信息（如程序计数器、通用寄存器中的内容） 进程调度方式 非抢占方式 抢占方式（优先权原则、短作业/进程优先原则、时间片原则） 中级调度 目的：提高内存利用率和系统吞吐量 功能：把暂时不能运行的进程从内存调出到外存中挂起，可以运行时，再由中级调度重新调入内存，并将进程插入就绪队列，等待进程调度 程序执行流程（1）作业进入系统（外存后备队列），创建JCB（2）作业调度 选作业 创建进程 分配资源 申请并初始化PCB （3）进程进入内存（内存就绪队列）（4）进程调度 调度算法先来先服务调度算法FCFS 最简单的调度算法，可用于作业调度、进程调度 有利于长作业（进程）、不利于短作业（进程） 短作业（进程）优先调度算法SJ(P)F高优先权优先调度算法 可用于批处理系统中作业调度；也可用于实时系统中进程调度 按中断的方式又分为：非抢占式优先权算法、抢占式优先权算法 高响应比优先调度算法（动态优先权）照顾了短作业优先算法时，长作业得不到处理机的问题；即随着时间的增长，长作业的优先级越来越高 基于时间片的轮转调度算法（分时系统） 优点：能及时响应用户请求 适用于分时系统的可抢占式的调度算法 实现方法：由计时器发出时钟中断，引起一次轮转调度 多级反馈队列调度算法（性能最好） 特点：事先不知道各种进程所需的执行时间 实现： 在内存中设置多个进程就绪队列，且每个队列的优先级不同，各个队列中的进程执行时间片不同（优先级高，时间片小）； 一个新进程进入内存后，首先放入第一个队列（优先级最高）的末尾，按FCFS原则排队等待调度； 进程在第一个队列执行完则撤离系统，未执行完则转入第二个队列的末尾； 仅当第一个队列空闲时，才调度第二个队列的进程 死锁 死锁：多个进程在运行过程中因争夺资源而陷入僵局 死锁原因：（1）竞争资源（2）进程间推进顺序非法 处理死锁的基本方法：（1）预防死锁：设置限制条件（2）避免死锁：在资源动态分配过程中，以某种方法防止系统进入不安全状态（3）检测死锁：允许死锁，检测并清除之（4）解除死锁：检测死锁并使之解脱]]></content>
      <categories>
        <category>《计算机操作系统》</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统（一）]]></title>
    <url>%2F2019%2F08%2F29%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[You have to believe in yourself. That’s the secret of success. ——Charles Chaplin 操作系统概述 为什么学OS OS是配置在计算机硬件上的第一层软件，大量应用软件都依赖于操作系统的支持、取得它的服务 OS的有效性：提高系统资源的利用率，提高系统的吞吐量 OS的方便性：OS使得计算机更容易使用 概述OS的作用 管理计算机系统资源 处理器管理 存储器管理 IO设备管理 文件管理 作为用户与计算机硬件系统之间的接口（1）使用计算机的三种方式： 命令方式（通过键盘输入取得操作系统的服务，控制用户程序的运行） 系统调用方式（通过系统调用与操作系统通信，取得它的服务） 图形、窗口方式 （2）操作系统与用户之间的接口 用户接口 程序接口 实现了对计算机资源的抽象 OS的发展过程一、无操作系统 人工操作方式（人机矛盾）缺点：用户独占全机，CPU等待人工操作 脱机输入/输出方式 二、单道批处理系统主要特征：自动型、顺序性、单道性 三、多道批处理系统优点：资源利用率高、系统吞吐量大缺点：平均周转时间长、无交互能力 四、分时系统（CTSS） 能将一台计算机提供给多个用户同时使用 解决的问题：人机交互、共享主机、便于用户上机 实现人机交互的关键：作业直接进入内存、每个作业只运行一个时间片 分时系统的特征：多路性、独立性、及时性、交互性 五、实时系统实时系统的特征：多路性、独立性、及时性、交互性、可靠性 六、微机操作系统 单用户单任务操作系统 CP/M MS-DOS 单用户多任务操作系统 windows 多用户多任务操作系统 UNIX Solaris Linux 操作系统的特性 并发性 共享性 虚拟技术 异步性 一、并发性 并行与并发（1）并行：两个或多个事件同时发生（2）并发：两个或多个事件在同一时间段内发生，宏观上有多个程序同时进行，微观上这些程序只是分时交替执行（在多核处理器中，将多个并发的程序分配到不同的处理机上，就能实现并行执行） 进程与线程为使多个程序并发执行，系统要为每个程序建立进程。（1）进程：系统中能独立运行，并作为资源分配的基本单位。多个进程之间可以并发执行和交换信息（2）线程：进程中可以包含多个线程，共同拥有进程的资源。进程是资源分配的基本单位，线程是独立运行和调度的基本单位 二、共享性（资源共享、资源复用） 互斥共享某些资源虽然可提供给多个进程/线程使用，但规定一段时间内只允许一个进程/线程访问该资源 同时访问宏观上的“同时”，微观上分时交替 三、虚拟技术 时分复用技术 虚拟处理机技术 虚拟设备技术 空分复用技术 虚拟磁盘技术 虚拟存储器技术 四、异步性进程以不可预知的速度向前推进，此即进程的异步性]]></content>
      <categories>
        <category>《计算机操作系统》</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用Linux命令]]></title>
    <url>%2F2019%2F08%2F29%2F%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[All that you do, do with your might; things done by halves are never done right.——R.H. Stoddard 1. 查看进程 ps -fu [用户名] 2. 杀进程 kill -9 [进程号] 3. 查看一个程序是否运行 ps –ef|grep tomcat （查看所有有关tomcat的进程） 显示所有用户所有终端的所有程序 ps -aux 4. 清缓存 rm -rf Catalina （提示：一定要在tomcat的work目录下执行此命令） 5. 重启项目 ./startup.sh 6. 查看日志 tail -f catalina.out 7. 查找日志记录 vi + catalina 8. 当前工作目录的绝对路径 pwd 9. 创建目录 mkdir newfolder 10. 删除空目录 rmdir deleteEmptyFolder 11. 递归删除目录中所有内容 rm -rf deleteFile 12. 查看文件，包含隐藏文件 ls -al 13. 复制文件 cp source dest 14. 递归复制整个文件夹 cp -r sourceFolder targetFolder 15. 远程拷贝 scp sourecFile romoteUserName@remoteIp:remoteAddr 16. 移动文件 mv /temp/movefile /targetFolder 17. 重命令 mv oldNameFile newNameFile 18. 压缩文件 tar -czf test.tar.gz /test1 /test2 19. 列出压缩文件列表 tar -tzf test.tar.gz 20. 解压文件 tar -xvzf test.tar.gz 21. 查看文件头10行 head -n 10 example.txt 22. 查看文件尾10行 tail -n 10 example.txt 23. 查看日志类型文件 tail -f exmaple.log （这个命令会自动显示新增内容，屏幕只显示10行内容的（可设置）） 24. 使用管理员身份删除文件 sudo rm a.txt 25. 修改文件权限 chmod 777 file.java （file.java的权限-rwxrwxrwx，r表示读、w表示写、x表示可执行） 26. 查找文件 find / -name filename.txt 根据名称查找/目录下的filename.txt文件。 find . -name &quot;*.xml&quot; 递归查找所有的xml文件 find . -name &quot;*.xml&quot; |xargs grep &quot;hello world&quot; 递归查找所有文件内容中包含hello world的xml文件 grep -H &apos;spring&apos; *.xml 查找所有的包含spring的xml文件 find ./ -size 0 | xargs rm -f &amp;amp; 删除文件大小为零的文件 ls -l | grep &apos;.jar&apos; 查找当前目录中的所有jar文件 grep &apos;test&apos; d* 显示所有以d开头的文件中包含test的行。 grep &apos;test&apos; aa bb cc 显示在aa，bb，cc文件中匹配test的行。 grep &apos;[a-z]\{5\}&apos; aa 显示所有包含每个字符串至少有5个连续小写字符的字符串的行。 27. 切换用户 su -username 28. 查看端口占用情况 netstat -tln | grep 8080 查看端口8080的使用情况 29. 查看端口属于哪个程序 lsof -i :8080 30. 网络检测 ping www.just-ping.com 31. 远程登录 ssh userName@ip 32. 打印信息 echo $JAVA_HOME 打印java home环境变量的值]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TWHomework——生成迷宫]]></title>
    <url>%2F2019%2F08%2F29%2FTWHomework%E2%80%94%E2%80%94%E7%94%9F%E6%88%90%E8%BF%B7%E5%AE%AB%2F</url>
    <content type="text"><![CDATA[The best hearts are always the bravest. 题目 问题 用计算机生成迷宫是一个很有趣的任务。我们可以用道路网格(Road Grid) 来表示迷宫的道路，那么3 x 3的道路网格（图-1 左）可以对应一个7 x 7的渲染网格(Render Grid)——图-1 右的方式（迷宫的墙是灰色的，道路是白色的）： 如果我们将迷宫道路网格两个相邻的cell连通，则可以打通道路。如图-2所示： 连通 道路网格 有如下的约束条件：● 每一个 cell 只能够直接与相邻正南、正北、正东、正西的 cell 连通。不能够和其他的 cell 连通。● 两个 cell 之间的连通一定是双向的。即 cell(0,0) 和 cell(1,0) 连通等价于 cell(1,0) 和 cell(0,0) 的连通。 要求1：将迷宫渲染为字符串 现在我们希望你书写程序，将给定迷宫的道路网格，渲染为字符串输出。例如，其使用方式如下（伪代码，仅做演示，实际实现时请应用实际语言的编程风格）12Maze maze = MazeFactory.Create(command);String mazeText = maze.Render(); 其中 command 是一个字符串。它的定义如下：● 第一行是迷宫道路网格的尺寸。例如 3 x 3 的迷宫为 3 3 ，而 5 x 4 的迷宫为 5 4 （5 行 4 列） 。● 第二行是迷宫道路网格的连通性定义。如果 cell(0,1) 和 cell(0,2) 是连通的，则表示为：0,1 0,2 ，多个连通以分号 ; 隔开。 要求2：检查输入的有效性 在处理输入的时候需要检查输入的有效性。需要检查的有效性包括如下的几个方面：● 无效的数字：输入的字符串无法正确的转换为数字。此时，该函数的输出为字符串 ”Invalidnumber format . ”● 数字超出预定范围：数字超出了允许的范围，例如为负数等。此时，该函数的输出为字符串”Number out of range . ”● 格式错误：输入命令的格式不符合约定。此时，该函数的输出为字符串 ”Incorrect commandformat . ”● 连通性错误：如果两个网格无法连通，则属于这种错误。此时，该函数的输出为字符串 ”Mazeformat error.”当多个问题同时出现时，报告其中一个错误即可。 思路1、观察给定用例的输入输出可得出以下规律： （1）输入的第一行字符串“m n”用来确定迷宫的大小（scale），行数row=m2+1，列数column=n2（2）输入的第二行字符串用来确定哪两个网格之间连通（path），并可以通过每一组网格的坐标及其之间的关系确定连通节点在新的迷宫中的位置 2、迷宫由两个参数确定（1）int[][] mazeArray首先由第一行字符串确定迷宫大小，此二维数组的每一个元素为mazeArray[i][j]，若i或者j其中有一个偶数，则将该元素暂时赋值为0（代表墙W），其余位置确定赋1（代表初始通路R）；后面需要根据输入字符串的第二行确定其他通路，修改此代表迷宫的二维数组mazeArray，将原本暂时赋的0改为1。 （2）int[][] pathArray将输入字符串第二行的处理为另一个二维数组pathArray，第一维度代表对字符串分组后的下标，第二维度代表每一个分组中的4个数字； 例如0,1 0,2;0,0 1,0可以被分为两组，其中第一组中的元素分别为pathArray[0][0]=0，pathArray[0][1]=1，pathArray[0][2]=0，pathArray[0][3]=2 3、确定连通节点在迷宫数组中的坐标经过初始化的迷宫有了，怎么根据pathArray[][]找到int[][] mazeArray中连通节点的坐标呢？规律如下：假设输入一组字符串“0,1 0,2”，根据在迷宫中的对应位置分别记为“x1,y1 x2,y2”，那么有：（1）x1和x2、y1和y2必有一对相等，且不相等的一对数字必定相差1；（2）连通节点的坐标mazeArray[a][b]：若x1=x2，a=x12+1,b=max(y1,y2)2；若y1=y2，a=max(x1,x2)2+1,b=y12由此找到了其余连通节点在mazeArray中的坐标，将该位置上的元素重新置为1。 代码Test.java MazeFactory.java Maze.java Const.java 代码说明总体分为四个类（1）Test.java——主函数所在类键盘输入两行字符串，调用下面两个方法分别用来创建Maze对象，生成迷宫字符串mazeText。Scanner scanner = new Scanner(System.in);Maze maze = MazeFactory.createMaze(scaleInput,pathInput);String mazeText =maze.render(); （2）MazeFactor.java——迷宫工厂类分为两个模块创建Maze模块：createMaze方法中调用验证模块，对输入字符串进行处理，构造两个二维数组int[][] mazeArray,int[][] pathArray，并将此作为maze方法的参数传入Maze maze = new Maze(mazeArray,pathArray)，返回Maze对象验证模块：由于第一行和第二行的输入格式内容不同，验证规则也不同，所以分为两个部分。同时，对每一行输入进行4种验证：验证格式错误、验证非连通性、验证无效数字、验证数字超出预定范围 验证格式错误：用字符串匹配正则表达式实现，两行输入都应当把格式错误作为第一个验证方法 验证非连通性：对于第一行，非连通性指输入为为“0 0” 或者“1 1”或者“0 1”或者“1 0”，因为这四种情况没有连通性可言；对于第二行，非连通性指“x1,y1 x2,y2”中，x1和x2、y1和y2必有一对相等，且不相等的一对数字必定相差1 验证无效数字：题目中的解释为“输入的字符串无法正确的转换为数字”，个人认为无效数字也属于格式错误的一种，例如“x1,y1 x2,y2”中有一个字母，因而无法转换为数字，但是要求每一项数字也是格式正确的一方面 验证数字超出预定范围：判断“x1,y1 x2,y2”中每一个数字都大于0，并且小于对应的行和列 （3）Maze.java——迷宫类 创建StringBuilder容器，准备将处理后的迷宫二维数组渲染为迷宫字符串mazeText输出； 比较二维数组pathArray[][]中的元素，用来确定迷宫mazeArray[][]中通路的坐标，即要把哪里重置为1 遍历迷宫二维数组，将处理后的迷宫二维数组渲染为迷宫字符串mazeText输出 （4）Constant.java——常量类包含了其他类中用到的常量： public static final String INCORRECT_COMMAND = &quot;Incorrect command format.&quot;; public static final String INVALID_NUMBER = &quot;Invalid number format.&quot;; public static final String OUT_OF_RANGE = &quot;Number out of range.&quot;; public static final String SCALE_FORMAT_OK = &quot;scaleformat is ok&quot;; public static final String PATH_FORMAT_OK = &quot;pathformat is ok&quot;; public static final String SCALE_REGEX1 = &quot;^-?\\d+\\s-?\\d+$&quot;; public static final String SCALE_REGEX2 = &quot;-?\\d+&quot;; public static final String PATH_REGEX1 = &quot;^(-?\\d+,-?\\d+\\s-?\\d+,-?\\d+;)*(-?\\d+,-?\\d+\\s-?\\d+,-?\\d+)$&quot;; public static final String PATH_REGEX2 = &quot;^\\[(-?\\d,\\s){3}-?\\d\\]$&quot;; 测试用例注意：（1）下面用例中，第一行、第二行为输入，下面即为输出；紧接着是另一组的输入……（2）运行主程序进行测试，首先需要键盘录入两行字符串作为输入，回车即可得到测试输出结果（迷宫或者验证错误信息提示）。 正常输出用例：1234567891011121314151617181920212223242526272829302 30,0 0,1;0,1 1,1[W] [W] [W] [W] [W] [W] [W][W] [R] [R] [R] [W] [R] [W][W] [W] [W] [R] [W] [W] [W][W] [R] [W] [R] [W] [R] [W][W] [W] [W] [W] [W] [W] [W]1 30,1 0,2[W] [W] [W] [W] [W] [W] [W][W] [R] [W] [R] [R] [R] [W][W] [W] [W] [W] [W] [W] [W]3 10,0 1,0[W] [W] [W][W] [R] [W][W] [R] [W][W] [R] [W][W] [W] [W][W] [R] [W][W] [W] [W]3 30,1 0,2;0,0 1,0;0,1 1,1;0,2 1,2;1,0 1,1;1,1 1,2;1,1 2,1;1,2 2,2;2,0 2,1[W] [W] [W] [W] [W] [W] [W][W] [R] [W] [R] [R] [R] [W][W] [R] [W] [R] [W] [R] [W][W] [R] [R] [R] [R] [R] [W][W] [W] [W] [R] [W] [R] [W][W] [R] [R] [R] [W] [R] [W][W] [W] [W] [W] [W] [W] [W] 每一种错误的测试用例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657230,0 0,1;0,1 1,1Incorrect command format.0,0 0,1;0,1 1,1Incorrect command format.2,30,0 0,1;0,1 1,1Incorrect command format.2 a0,0 0,1;0,1 1,1Incorrect command format.2a0,0 0,1;0,1 1,1Incorrect command format.2,a0,0 0,1;0,1 1,1Incorrect command format.0 00,0 0,1;0,1 1,1Maze format error.0 10,0 0,1;0,1 1,1Maze format error.1 00,0 0,1;0,1 1,1Maze format error.1 10,0 0,1;0,1 1,1Maze format error.-2 30,0 0,1;0,1 1,1Number out of range.2 3a,0 0,1;0,1 1,1Incorrect command format.2 30,0,0,1;0,1 1,1Incorrect command format.2 30,0;0,1;0,1 1,1Incorrect command format.2 3Incorrect command format.2 30,0Incorrect command format.2 3a,0 0,1;0,1 1,1Incorrect command format.2 30,0 0,-1;0,1 1,1Number out of range.2 30,0 0,2;0,1 1,1Maze format error. 总结遇到的问题 找到输入字符串和输出迷宫的规律之后，就马上着手写了，一个Homework类从头写到尾，运行该主程序直接按照题目给定的输入得到了给定的输出。但其中存在很多问题，没有加验证、没有将各个功能模块分类、代码不是很简洁、存在一些细节上的问题… 后面加了验证，并将功能实现分为了4个类，进行了一些代码细节的优化。这个过程中的一些问题如下 输入格式的问题 最开始以为输入字符串是一行，所以将输入作为用一个字符串变量标记，第一行和第二行的中间用&quot;\r\n&quot;隔开 问题：但是这样做没有考虑到后面字符串的格式验证，因为第一行和第二行的验证规则是不同的，如果不分开用不同的变量标记，比较难处理 解决：将输入作为两行，用两个字符串变量标记 对第一行输入的处理问题 最开始没有对&quot;3 3&quot;进行进一步切割，所以在取两个数字的时候使用了 int | String.charAt(index)-48 得到了int类型的数字 问题：这样做使用题目给定的测试用例可以得到正确的输出，但是当&quot;m n&quot;中m或n有一个超过两位数字，对char类型-48就不能得到正确的int类型的数值 解决：将&quot;3 3&quot;进一步用&quot;\\s&quot;切割，得到String[]数组，对数组中的每一个String元素用Integer.parseInt(String元素)就能得到正确的int类型的数值 输入没有进行键盘录入 问题：最开始将输入写成固定的了，不方便进行测试没有进行键盘录入 解决：在Test类（主类）中加上了扫描器进行键盘录入 字符串常量池 问题：最开始把所有的字符串直接在功能实现类中写着，看起来不够简洁 解决：创建了一个Constant类，把用到的字符串常量都定义在里面作为静态常量被调用。包括用到的错误信息展示、flag、正则表达式 Maze类的属性的确定问题：最开始对迷宫对象的属性不知道怎么定义，即要用哪几个变量唯一确定一个迷宫。 解决：（1）private int[][] mazeArray;//初始迷宫二维数组 private int[][] pathArray;//用来找通路坐标 （2）根据思路中提到的规律，若把墙&quot;[W]&quot;看作int类型的0，通路&quot;[R]&quot;看作int类型的1，则整个迷宫就是一个二维数组 int[][] mazeArray （3）按照规律对二维数组mazeArray进行初始化，得到一部分的通路，其余的通路要由输入的第二行字符串按照相应的规律确定， 此时就需要对第二行字符串切割后把所有数字存入另一个二维数组int[][] pathArray，对pathArray中的元素进行比较后得到通路[R]在迷宫mazeArray中的坐标 重置该坐标的元素为1，就能得到最终的迷宫数组了 验证第一行输入过程中的问题 问题1：4种验证方法的前后顺序需要考虑。不然会引起前面的验证方法把后面的几种错误全都给拦截了的问题（当然这还与验证的规则——正则表达式有关） 解决1：格式验证一定在第一个；其次是连通性验证；再是无效数字验证；最后是超范围验证。 问题2：格式验证的正则表达式书写。这个正则必须只验证格式，把后面几种错误都放过去。最开始写的时候没有加负号&quot;-&quot;，结果把超范围错误的负数错误给拦截到格式错误中了。 包括在第二行输入字符串格式验证的正则表达式中，也出现了同样的问题。 解决2：在正则中加上了对于负号的验证。 问题3：关于无效数字的验证。题目中对于无效数字的定义为：不能转换为正确的数字。个人认为无效数字应该也属于格式错误的一种。 例如，因为pathArray中有一个元素是字母不能正确转为数字，那么这种输入本身的格式就不对。 解决3：在无效数字验证方法中，使用和格式验证同样的正则做了匹配验证 问题4：对于第一行输入非连通性的定义 解决4：个人认为scaleInput为“0 0” 或者“1 1”或者“0 1”或者“1 0”，这四种情况下没有连通性可言。 验证第二行输入过程中的问题 问题1：4种验证方法的前后顺序需要考虑。不然会引起前面的验证方法把后面的几种错误全都给拦截了的问题（当然这还与验证的规则——正则表达式有关） 解决1：格式验证一定在第一个；其次是无效数字验证；再是超范围验证；最后是连通性验证。 与第一行顺序稍有不同，因为第二行的连通性定义不同：假设有一组输入为&quot;x1,y1 x2,y2&quot;，x1和x2、y1和y2必有一对相等，且不相等的一对数字必定相差1。 问题2：超范围验证的时候，最开始只把x1,y1,x2,y2和row、column进行了比较，没有和0进行比较，因为负数也是超范围的一种 解决2：分别把x1,y1,x2,y2和0进行了比较。 需要改进的地方 验证部分写在了工厂类MazeFactory中，是不是可以把验证单独作为一个类 验证第二行字符串的时候，需要拿到字符串中的每一个数字，于是又在验证模块中把字符串重新处理为二维数组int[][] pathArray，但是这一步在同一类中的createMaze(String scaleInput,String pathInput)方法中已经实现 写验证模块判断条件比较长，例如验证第二行字符串超范围错误的条件用了很多个或”||”]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>Maze</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learn to Git]]></title>
    <url>%2F2019%2F08%2F29%2FLearn-to-Git%2F</url>
    <content type="text"><![CDATA[Sharp tools make good work. Git是什么？Git是目前最先进的分布式版本控制系统 和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库 Git相比于其他版本管理系统具有极其强大的分支管理功能 Git最大的优势是远程仓库的功能，Github可以提供Git仓库托管服务 安装Git官网下载安装Git安装完成后，在开始菜单里找到”Git”-&gt;”Git Bash Here”，弹出一个命令行窗口就说明你的Git安装成功啦！还需做以下简单设置： 第一步：设置global参数。因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址$ git config --global user.name &quot;Your Name&quot; $ git config --global user.email &quot;email@example.com&quot; 第二步：创建版本库（1）创建一个目录。版本库创建完成后这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”（2）通过git init命令把这个目录变成Git可以管理的仓库。当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的 第三步：把文本文件（.txt/.html/程序源码）添加到版本库（1）用命令git add告诉Git，把文件添加到仓库：$ git add readme.txt （2）用命令git commit告诉Git，把文件提交到仓库：$ git commit -m &quot;wrote a readme file&quot; git statusgit status命令可以让我们时刻掌握仓库当前的状态(4种) 未添加文件到仓库（暂存区）untracked 修改了，未添加新的修改到仓库（暂存区） 将修改添加到暂存区了，待提交 没有可以提交的修改 其他git命令 git diff顾名思义就是查看difference（具体修改了什么内容），显示的格式正是Unix通用的diff格式$ git diff readme.txt git log命令显示从最近到最远的提交日志，弹出commit id（版本号），后面可以加上参数 –pretty=oneline git reset回退到上一个版本（回到历史）： $ git reset --hard HEAD^ 跳到指定版本号（穿梭到未来（需要版本号）、回到历史）： $ git reset --hard 3628164 git reflog用来记录你的每一次命令，用它可以找到以前的版本号 工作区、暂存区（stage）、分支（master）我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支 git commit只负责把暂存区的修改提交了（每次修改，如果不add到暂存区，那就不会加入到commit中） 撤销和删除撤销修改 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令：git checkout – file 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，可以选择回退到之前的版本git reset –hard HEAD^，不过前提是没有推送到远程库 删除文件步骤一般情况下，你通常直接在文件管理器中把没用的文件删了 情景一：确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit 情景二：删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本git chechout –file git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 远程仓库GitHub创建并添加SSH Key本地Git仓库和GitHub仓库之间的传输是通过SSH加密的 创建SSH key $ ssh-keygen -t rsa -C “youremail@example.com“ 添加SSH key登陆GitHub，打开“Account settings”——&gt;“SSH Keys”页面——&gt;点“Add SSH Key”，填上任意Title——&gt;在Key文本框里粘贴id_rsa.pub文件的内容 链接本地git版本库和远程github版本库现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得 首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：名称与本地git仓库最好一致 将本地仓库与github仓库关联：$ git remote add origin git@github.com:github账户名/github上的仓库名.git 添加后，远程库的名字就是origin 把本地库的所有内容第一次推送到远程库上：$ git push -u origin master 注意：（1）把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程（2）由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样 从现在起，只要本地作了提交，就可以通过命令：$ git push origin master 把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！ 删除已有远程库origin 本地库已经关联了一个名叫origin的远程库，此时，可以先用git remote -v查看远程库信息 我们可以删除已有的GitHub远程库：git remote rm origin]]></content>
      <categories>
        <category>hello git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo&GitPages建站历程]]></title>
    <url>%2F2019%2F08%2F29%2FHexo-GitPages%E5%BB%BA%E7%AB%99%E5%8E%86%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Let’s make a difference. 毛主席说了：前途是光明的，道路是曲折的。 写在前面 这是我开始搭建个人博客的第三天，有了自己的一亩三分地，很开心。现在看来搭建个人博客并不是最初想的那么难，但即使按照教程来做，还是会遇到很多问题。接下来分享我使用hexo+gitpages搭建博客的过程以及一些你可能也卡壳的地方，希望能帮助到你。 我会分为三部分介绍，第一部分搭建起博客的雏形，第二部分做一些个性化的配置（这个真的好玩，但也耗费时间），第三部分是我遇到的几个问题，避免你犯同样的错误浪费时间。 一 上线你的博客获得个人网站域名在阿里云购买属于你的域名 GitHub创建个人仓库登录注册GitHub，点击GitHub中的New repository创建新仓库，仓库名应该为：用户名.github.io 安装GitGit是开源的分布式版本控制系统，用于敏捷高效地处理项目。我们网站在本地搭建好了，需要使用Git同步到GitHub上。 下载安装Git，在菜单里搜索Git Bash，设置user.name和user.email配置信息：git config –global user.name “你的GitHub用户名”git config –global user.email “你的GitHub注册邮箱” 生成ssh密钥文件：ssh-keygen -t rsa -C “你的GitHub注册邮箱”然后直接三个回车即可，默认不需要设置密码然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制在github中找到Settings，新建new SSH Key在Git Bash中检测GitHub公钥设置是否成功，输入ssh git@github.com 安装Node.jsHexo基于Node.js，下载安装Node.js，检测Node.js是否安装成功，在命令行中输入 node -v，检测npm是否安装成功，在命令行中输入npm -v 到这了，安装Hexo的环境已经全部搭建完成！！！ 安装Hexo 在本地创建Blog文件夹，然后Git Bash Here npm install -g hexo-cli安装Hexo 初始化Blog hexo init 新建博客并本地预览，检测网站本地是否能打开 hexo new test_my_site hexo g hexo s 浏览器输入 localhost:4000 推送网站将hexo创建的博客相关文件推送到github上 将Hexo与GitHub关联打开站点的配置文件_config.yml，翻到最后修改为：（注意：每一个冒号后面都有一个空格） deploy: type: git repo: 这里填入你之前在GitHub上创建仓库的完整路径，记得加上 .git branch: master 安装Git部署插件，输入命令：npm install hexo-deployer-git –save 这时，我们分别输入三条命令： hexo clean hexo g hexo d 完成后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即git用户名.github.io，你就会发现你的博客已经上线了，可以在网络上被访问了！！！ 绑定域名 登录到阿里云，进入管理控制台的域名列表，找到你的个性化域名，进入解析 添加CNAME解析： CNAME的记录值是：你的用户名.github.io 登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名, save 进入本地博客文件夹 ，进入blog/source目录下，创建一个没有后缀的文件命名为CNAME，输入你的域名，保存 git bash依次输入：hexo clean hexo g hexo d 打开浏览器在地址栏输入你的个性化域名将会直接进入你自己搭建的网站！！！ 二 个性化设置更换主题 下载next主题： git clone https://github.com/iissnan/hexo-theme-next themes/next 修改站点配置文件_config.yml中的theme: next 在主题配置文件_config.yml中的Scheme Settings，可以选择next主题的样式 设置头像在站点 _config.yml 中添加 avatar: http://…. # 头像的URL（可以在markdownpad2中Ctrl+G生成） 添加网易云音乐模块 修改blog\themes\next\layout_macro的sidebar.swig文件，添加网易云音乐网页版中音乐的外链代码 设置音乐是否自动播放：修改代码中的auto为0/1即可 设置背景 把你挑选的背景图片命名为：background.jpg，放在blog\themes\next\source\images里，在blog\themes\next\source\css_custom文件的custom.styl首部添加： body {background:url(/images/background.jpg);background-attachment: fixed;} background-attachment: fixed;是固定背景图片。 这是设置一张静态图片作为背景，其实Next主题自带有动态的背景效果，修改主题配置文件中的canvas_nest: false为canvas_nest: true即可 增加侧栏条目 修改主题配置文件_config.yml里的Menu Settings中的menu和menu_icons两个地方。 其中menu里是配置菜单项对应的页面位置（如：/love），menu_icons对应菜单项的图标，这里的图标是来自于Font Awesome ，所以你需要在Font Awesome网站上找到你需要的icon，然后把该icon的名字写在menu_icons对应菜单名后面，注意冒号有一个英文输入状态的空格。 设置好后，在命令行里输入：hexo new page “你所要增加的菜单项名称（要和你在menu中的填写要匹配）” 新建的页面在博客根目录下的source文件里，这时你就可以对新建的页面自定义设计。 隐藏底部的poweredby打开themes/next/layout/_partials/footer.swig,使用隐藏之间的代码即可 &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;div class=&quot;theme-info&quot;&gt;&lt;/div&gt; 在每篇博文下面添加版权信息 详见https://thief.one/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/ 如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置 主页文章添加阴影效果打开\themes\next\source\css_custom\custom.styl,向里面加入： // 主页文章添加阴影效果 .post { margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); } 修改文章底部的那个带#号的标签修改模板/themes/next/layout/_macro/post.swig，搜索rel=”tag”&gt;#，将 # 换成 将链接文本设置为蓝色.post-body p a { color: #0593d3; border-bottom: none; &amp;:hover { color: #0477ab; text-decoration: underline; } } 在右上角或者左上角实现fork me on github修改 themes/next/layout/_layout.swig文件，放在 的下面，并把href改为你的github地址 添加来必力评论系统 注册Livere，获取livere_uid，参考教程https://blog.smoker.cc/web/add-comments-livere-for-hexo-theme-next.html 在主题 _config.yml 文件中添加如下配置： livere_uid= “你的来必力UID” 三 卡住我的地方域名申请申请购买到属于你的域名后，一定要先实名认证，上传你的身份证正面照片即可（认证过程大约一两个小时）阿里云注册的域名不认证用不了，我当时已经在本地部署好了博客网站的雏形（也就是hexo s后，浏览器打开localhost:4000），而且设置好域名CNAME解析到github用户名.github.io，但是在浏览器输入域名就404找不到网页。原因就是你的域名还不能用啊。 推送网站把hexo生成的博客部署/推送在github上这一步，修改站点配置文件_config.yml时要注意： deploy: type: git repo: branch: master 这些代码每一个冒号后面都有一个空格，我浪费了大半天时间在同学的帮助下才找这个问题 添加来必力评论系统最新版本的hexo已经支持第三方levere插件的一键配置，只需要在主题 _config.yml 文件中找到livere_uid，取消其注释并加上你获取到的livere_uid即可。已经不需要向以前很多博文中介绍的那样，添加修改各种文件和代码了。 写在最后我的建站历程终于到此为止啦，希望你也建站顺利！在此感谢AbelChao同学的帮助让我少走了很多弯路！感谢橙子彤倾情赞助的首页美图！ 可供参考的其他建站资料Hexo+GithubPages&amp;CodingPages搭建自己的个人博客GitHub+Hexo 搭建个人网站详细教程Hexo搭建博客教程hexo的next主题个性化教程:打造炫酷网站next主题配置]]></content>
      <categories>
        <category>hello hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今天建站啦]]></title>
    <url>%2F2019%2F08%2F29%2F03-29%E5%BB%BA%E7%AB%99%2F</url>
    <content type="text"><![CDATA[Brevity is the soul of wit. 橙子彤你好： 欢迎你来到我的博客空间~ 这是我的github]]></content>
      <categories>
        <category>hello hexo</category>
      </categories>
      <tags>
        <tag>say hello</tag>
      </tags>
  </entry>
</search>
