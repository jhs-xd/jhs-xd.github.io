---
title: 深入理解JVM（二）
copyright: true
categories: 
  - 《深入理解JVM》
tags: 
  - JVM

---
<blockquote class="blockquote-center"> A contented mind is the greatest blessing a man can enjoy in this world.
![](/myimages/10.jpg)<blockquote>

虚拟机执行子系统

<!-- more -->

---

# 虚拟机执行子系统 #

- 类文件结构
- 虚拟机类加载机制
- 虚拟机字节码执行引擎

---

## 类文件结构 ##

一次编写，到处运行：
虚拟机提供商发布了可以运行在各种不同平台上的虚拟机，这些虚拟机都可以载入和运行相同的字节码。
虚拟机并不关心Class文件的来源是何种语言。

### Class文件格式 ###
1. Class文件的数据结构：无符号数、表
（1）无符号数（基本数据类型）：用来描述数字、索引引用、数值量，或者按照UTF-8编码构成字符串值，u1、u2、u4、u8
（2）表（复合数据类型）：用于描述有层次关系的复合结构的数据，以“_info”结尾
![](/myimages/10Class文件格式.png)

2. Class文件格式
Class的结构没有任何分隔符，所以上表中的数据项，无论是顺序还是数量都是被严格限定的
（1）魔数与Class文件的版本
魔数（Magic Number）：唯一作用是确定这个文件是否是一个能被虚拟机接受的Class文件
版本号（Minor Version、Major Version）
（2）常量池
Class文件的资源仓库，主要存放字面量、符号引用。
		字面量：文本字符串、声明为final的常量值。
		符号引用：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。
		常量池的特点：
		1.是Class文件结构中与其他项目关联最多的数据类型
		2.占用空间最大的数据类型
		3.Class文件中第一个出现的表类型数据
（3）访问标志
用于识别类或接口的访问信息
（4）类索引、父类索引、接口索引集合
Class文件中由这三项数据来确定这个类的继承关系
（5）字段表集合
用于描述接口或类中声明的变量
（6）方法表集合
用于描述接口或类中声明的方法
（7）属性表结合
在Class文件、字段表、方法表中都可以携带自己的属性表集合，用于描述某些场景下专有的信息

### 字节码指令 ###
Java虚拟机的指令有一个字节长度的操作码（代表某种特定的操作）和操作数（操作所需参数）构成。
大多数的指令都包含了其操作所对应的数据类型信息，例如iload指令用于从局部变量表中加载int型的数据到操作数栈中
（1）加载和存储指令
用于将数据在栈帧中的局部变量表和操作数栈之间来回传输
（2）运算指令
用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。大体可分为：操作整形数据的指令、操作浮点型数据的指令
（3）类型转换指令
将两种不同的数值类型进行相互转换，这些转换操作一般用于实现用户代码中的显式类型转换操作
（4）对象创建与访问指令
获取对象实例或者数组实例中的字段或数组元素
（5）操作数栈管理指令
用于直接操作操作数栈
（6）控制转移指令
让Java虚拟机有条件或无条件地从指定位置的指令继续执行程序
（7）方法调用和返回指令
方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的
（8）异常处理指令
显式抛出异常的操作（throw语句）都由athrow指令来实现
处理异常（catch语句）不是由字节码指令实现，而是采用异常表完成
（9）同步指令
方法级同步：隐式，无序通过字节码之灵来控制，实现在方法调用和返回操作之中
方法内部一段指令序列的同步

---

## 虚拟机类加载机制 ##
类加载机制：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型

为什么称Java为动态扩展语言？
运行期动态加载和动态连接，虽然令类加载时增加了性能开销，但为java应用程序提供了高度的灵活性

### 类的生命周期 ###

![](/myimages/10类的生命周期.jpg)

1. 加载、验证、准备、初始化和卸载这5个阶段的开始顺序是确定的，强调开始是因为这些阶段通常都是互相交叉混合执行的。
2. 什么时候开始类加载过程的第一个阶段——“加载”？没有强制约束
3. 对于初始化阶段，严格规定有且只有5种情况必须立即对类进行“初始化”，这5种场景中的行为称为对一个类进行主动引用
4. 加载、验证、准备需要在初始化之前开始

### 类加载的过程 ###
1. 加载
加载阶段完成后：
（1）通过一个类的全限定名获取定义此类的二进制字节流；
（2）虚拟机外部的二进制字节流按照虚拟机所需的格式存储在方法区；
（3）内存中实例化一个java.lang.Class类的对象（在方法区中），这个对象将作为程序访问方法区中的这些类型数据的外部接口
2. 验证
（1）作用：确保Class文件的字节流中包含的信息符合当前虚拟机的要求
（2）大致分为四个阶段：文件格式验证、元数据验证、字节码验证、符号引用验证
（3）验证阶段重要，但不必要
3. 准备
（1）作用：为类变量分配内存、设置类变量初始值（类变量存储在方法区中）
（2）准备阶段分配内存是给类变量分配内存，不包括实例变量
（3）设置初始值通常是零值
4. 解析
虚拟机将常量池内的符号引用替换为直接引用
5. 初始化
（1）除了加载阶段用户可自定义类加载器，验证、准备、解析完全由虚拟机主导和控制
（2）初始化阶段，才真正开始执行用户代码
（3）初始化阶段是执行类构造器< clinit >()方法的过程

### 类加载器 ###
类加载器：虚拟机外部，用来引导“类加载”过程的“加载”阶段执行的代码模块
1. 作用
（1）用于实现类的加载动作
（2）类加载器和类本身一起，用于确定一个类在Java虚拟机中的唯一性
2. 类加载器类型
（1）启动类加载器（Bootstrap ClassLoader）：虚拟机自身的一部分，由C++实现
（2）所有其他的类加载器，独立于虚拟机外部，由Java实现，全都继承自抽象类java.lang.ClassLoader
	- 扩展类加载器
	- 应用程序类加载器（系统类加载器）：程序中默认的类加载器
3. 类加载器之间的层次关系——双亲委派模型
双亲委派模型：类加载请求会优先委派给父类加载器去完成
好处：Java类随着他的类加载器一起具备了一种带有优先级的层次关系，这对于保证Java程序的稳定运作很重要

---

## 虚拟机字节码执行引擎 ##
执行引擎是Java虚拟机最核心的组成部分之一
从外观上看，所有的Java虚拟机的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码的等效过程，输出的是执行结果

### 运行时栈帧结构 ###
- 栈帧是虚拟机进行方法调用和方法执行的数据结构
- 栈帧与方法一一对应
- 栈帧存储了方法的局部变量表、操作数栈、动态连接、返回值地址等信息
- 栈帧是运行时数据区中的虚拟机栈的栈元素
- 对执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，成为当前栈帧，对应的方法称为当前方法
- 执行引擎运行的所有字节码指令都只对当前栈帧进行操作
1. 局部变量表
（1）用于存放方法参数和方法内部定义的局部变量
（2）在Java程序编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量
（3）局部变量表的容量以变量槽slot为最小单位
（4）虚拟机通过索引定位的方式使用局部变量表，索引值的范围从0开始至局部变量表最大的Slot数量
（5）局部变量表不存在类似类加载的“准备阶段”，因此如果一个局部变量定义了但没有赋初始值是不能使用的
2. 操作数栈
（1）存储方法执行过程中的数据
（2）后入先出LIFO
（3）同局部变量表一样，操作数栈的最大深度也在编译时写在方法的Code属性的max_stacks数据项中
（4）方法开始执行时，操作数栈是空的；方法执行过程中，会有各种字节码指令往操作数栈中写入和提取内容（入栈/出栈）
（5）操作数栈中元素的数据类型必须与字节码指令的类型严格匹配
（6）栈帧重叠：下面栈帧的操作数栈和上面栈帧的局部变量表重叠，这样在方法调用时就可以共用一部分数据，无需进行额外的参数复制传递
3. 动态连接
每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，这个引用是字节码方法调用指令的参数。
（1）静态解析
常量池中一部分符号引用会在类加载阶段或者第一次使用的时候转化为直接引用
（2）动态连接
另外一部分符号引用胡子爱每一次运行期间转化为直接引用
4. 方法返回地址
退出方法的两种方式：
（1）正常完成出口：执行引擎遇到任意一个方法返回的字节码指令（是否有返回值和返回值的类型由方法返回指令决定）
（2）异常完成出口：方法执行过程中遇到了异常，并且异常没有在方法体中得到处理（不会给上层调用者产生任何返回值）

### 方法调用 ###
Class文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在Class文件中存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（直接引用）
1. 静态解析
类加载的解析阶段，将一部分符号引用转化为直接引用
包括两类方法：静态方法、私有方法
2. 分派（多态性）
（1）静态分派
所有依赖静态类型来定位方法执行版本的分派动作称为静态分派
静态分派发生在编译阶段，不由虚拟机执行
典型应用：重载
（2）动态分派
在隐形器根据实际类型确定方法执行版本的分派过程称为动态分派
典型应用：重写
3. 动态类型语言
动态类型语言的关键特征是它的类型检查的主题过程是在运行期而不是编译期