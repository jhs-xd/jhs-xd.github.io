---
title: 深入理解JVM（三）
copyright: true
categories: 
  - 《深入理解JVM》
tags: 
  - JVM

---
<blockquote class="blockquote-center"> The greater a man is, the more distasteful is praise and flattery to him.
![](/myimages/11.jpg)<blockquote>

Java内存模型、线程、线程安全、锁优化

<!-- more -->

---

# Java内存模型 #

- 衡量一个服务（程序）性能的好坏——每秒事务处理数（TPS），TPS与程序的并发能力密切相关
- 实现并发编程的工具
	- Java语言和虚拟机提供的很多工具
	-  中间件服务器
	-  各类框架
- 硬件的效率与一致性
	- 硬件效率
			高速缓存：解决了处理器与内存之间的速度矛盾
	- 缓存一致性问题
			当多个处理器的运算任务涉及同一块主内存区域时，可能导致各自的缓存数据不一致
			此时，需要各个处理器访问缓存时遵循一些协议，根据协议进行读写操作

## 主内存与工作内存 ##
类似于硬件的效率与一致性问题：
工作内存解决了Java线程与主内存之间的速度矛盾，但是引入了线程安全的问题

![](/myimages/11工作内存与主内存.jpg)
1. Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存
2. 线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量

## 内存间交互操作 ##
1. 内存间交互操作：一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存
2. Java内存模型中定义了8中原子性的操作实现主内存与工作内存之间的交互
	- lock
	- unlock
	- read
	- load
	- use
	- assign
	- store
	- write
3. 线程读取主内存变量的过程
![](/myimages/11线程读取主内存变量的过程.png)

## volatile型变量 ##
1. volatile是Java虚拟机提供的最轻量级的同步机制
2. volatile作用：
	- 保证变量对所有线程的可见性
	- 禁止指令重排序优化（普通的变量不能保证变量赋值操作的顺序与程序代码中的执行顺序一致）

## 原子性、可见性、有序性 ##
Java内存模型是围绕着在并发过程中如何处理原子性、可见性、有序性这3个特征来建立的
1. 原子性
	- 基本数据类型的访问读写是原子性的
	- synchronized块之间的操作也具备原子性
2. 可见性
当一个线程修改了共享变量的值，其他线程能立即得知这个修改
（1）Java内存模型实现可见性的途径
变量修改后将新值同步回主内存，修改前从主内存刷新变量值（依赖于主内存作为传递媒介），**普通变量、volatile变量都是如此**
（2）volatile变量与普通变量的区别
volatile修饰的变量：新值立即同步，每次使用前立即从主内存刷新
（3）实现可见性的关键字：volatile、synchronized、final
3. 有序性
（1）本线程内观察，所有的操作都是有序的——线程内表现为串行
（2）如果在一个线程中观察另一个线程，所有的操作都是无序的——指令重排序现象
（3）实现有序性的关键字：volatile、synchronized

---

# Java线程 #

## 线程的实现 ##
线程的3中实现方式：使用内核线程实现、使用用户线程实现、使用用户线程加轻量级进程混合实现
1. 使用内核线程（KLT）实现
- 由**操作系统内核**完成线程切换——内核通过操纵**调度器**对线程进行调度，并负责将线程的任务映射到各个处理器上
- 程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口——**轻量级进程（LWP）**，与内核线程一一对应（就是通常意义上的线程）
- 优点：每个轻量级进程都是一个独立的调度单元，一个阻塞了不影响其他
- 缺点：基于内核线程实现，所以各种线程操作都需要进行系统调用，系统调用代价较高，需要在用户态和内核态之间来回切换；消耗内核资源
2. 使用用户线程实现
- 优点：不需要内核支援
- 缺点：所有线程操作都需要用户程序自己处理
3. 使用用户线程加轻量级进程混合实现
4. Java线程的实现：一条Java线程——一条轻量级进程——一条内核线程

## 线程的调度 ##
1. 协同式线程调度
2. 抢占式线程调度：每个线程由系统来分配执行时间
3. 线程优先级：Java提供了10个级别的线程优先级

## 线程状态转换 ##
1. 线程状态
	- 新建
	- 运行
	- 无限期等待
	- 限期等待
	- 阻塞
	- 结束
2. 线程状态转换
![](/myimages/11线程状态转换.png)

---

# 线程安全 #

## Java线程安全的分类 ##
按线程安全的“安全程度”分为5类：
- 不可变——final
- 绝对线程安全
- 相对线程安全——通常意义的线程安全
- 线程兼容——通常意义的线程不安全
- 线程对立
## 线程安全的实现方法 ##
1. 互斥同步（synchronized、ReentrantLock）
（1）synchronized是Java语言中一个重量级的操作，使用它需要java线程映射到内核线程，通过操作系统内核来实现同步，耗费很多处理器时间
（2）ReentrantLock相比synchronized增加了三项高级功能：
	- 等待可中断
	- 公平锁
	- 锁绑定多个条件
（3）优先考虑使用synchronized来进行同步
2. 非阻塞同步
（1）互斥同步进行线程阻塞和唤醒会带来性能问题，互斥同步属于一种悲观的并发策略（认为不进行同步处理肯定出问题）
（2）非阻塞同步（乐观的并发策略）：先进行操作，没有其他线程争用共享数据则操作成功；有其他线程争用共享数据则采取补偿措施
3. 无同步方案
	-  可重入代码（纯代码），所有的可重入代码都是线程安全的
	-  线程本地存储

---

# 锁优化 #
1. 锁优化目的
在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率
2. 锁优化技术
	-  适应性自旋
	-  锁消除
	-  锁粗化
	-  轻量级锁
	-  偏向锁