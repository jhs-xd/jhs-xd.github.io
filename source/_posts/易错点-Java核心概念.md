---
title: 易错点-Java核心概念
copyright: true
categories: 
  - 我的错题库
  - 牛客错题整理

---
**变量与常量；运算符；构造方法与一般（成员）方法；成员变量与静态变量；成员变量与局部变量；静态块、构造块、执行顺序优先级；关键字；继承、实现；抽象类、接口；重载、重写；多态；内部类；异常；包、权限；内存管理**
![](/myimages/3.jpg)

<!--more-->

---

# 变量与常量；运算符 #

## 区分变量、常量、形参 ##
变量是一个引用，常量代表一个数值，形参只是一个标识。

	1 变量有它对应的地址和值，需要为它开辟内存空间
	  变量存在于堆或栈中

	2 常量存在于常量池中，在类加载之前就已经被加载，且不会改变
	  实际应用中，常量常用来配置文件路径

	3 形参只是一个标识符号，用来传递实参

## 运算符 ##
	1 运算符优先级
	    括号>
		单元操作符>
		算术运算符>
		移位操作符>
		关系运算符>
		位运算符>
		逻辑运算符>
		三元操作符>
		赋值运算符

	2 区分&和&&
	  &在逻辑运算中是非短路逻辑与，在位运算中是按位与
	  &&在逻辑运算中是 逻辑与、短路

	3 区分|与||
	  用法：condition 1 | condition 2、condition 1 ||condition 2
	  "|"是按位或：先判断条件1，不管条件1是否可以决定结果（这里决定结果为true)，都会执行条件2
	  "||"是逻辑或：先判断条件1，如果条件1可以决定结果（这里决定结果为true)，那么就不会执行条件2

	4 计算机用补码存储数据
      -n=~n+1

	5 <<表示左移位
	  >>表示带符号右移位
	  >>>表示无符号右移
	  但是没有<<<运算符

	6 int a = 2, b = 0;  do { --b; } while (a --> 0);//判断循环结束后a/b的值
	  由于判断条件中--在后因此先做判断再--
      第一次进入do中b变为-1，此时a=2判断大于0为真，然后a--变为1
      第二次进入do中b变为-2，此时a=1判断大于0为真，然后a--变为0
      第三次进入do中b变为-3，此时a=0判断大于0为假，跳出while

	7 if (flag = true) //这是一个赋值运算，而不是判断是否相等。返回值为true

---

# 一对方法、两对变量 #

## 构造方法和成员方法 ##
1. 构造方法：①对象创建时自动调用，对该对象进行初始化；②只调用一次；③没有返回值；④构造器中的this()指向同一个类中重载的另一个构造器。
2. 成员方法：①对象创建后，需要主动调用；②可以调用多次；③必须有返回值；④方法中引用this指向该方法所属类的对象。


	1 判断：构造方法只能通过new自动调用（×）
	  解析：构造方法可以通过反射自动调用

	2 如果父类中只有有参构造函数，没有无参构造函数，则子类构造函数必须显式调用

	3 判断：如果子类只有一个有参构造函数，那么必然会调用父类中相同参数的构造函数
	  解析：可以调用父类无参的构造函数，子类的有参构造函数和是否调用父类的有参数的构造函数无必然联系

## 成员/实例变量与静态变量/类变量 ##
1. 二者生命周期不同：成员变量依存于对象，静态变量依存于类
2. 数据存储位置不同：成员变量存储于堆中，静态变量存储于方法区中
3. 调用方式不同：成员变量需要先创建对象，再通过“对象.成员变量”来调用，静态变量直接用类名调用


	1 关于变量初始化
	  无论是类变量还是实例变量，在使用前都是非空的。而局部变量没有初始化过程，在使用前必须赋值

	2 Java中静态变量只能在类主体中定义，不能在方法中定义；因为静态变量属于类所有而不属于方法

	3 判断代码结果：
	  public class Test
	{
    public int x;
    public static void main(String []args)
    {
        System. out. println("Value is" + x);
	//错误，非静态变量不能直接被静态方法引用。
	//可以先创建Test类的对象，用对象调用非静态变量。

## 成员/实例变量与局部变量 ##
局部变量作用在方法或区域代码块中

	1 局部变量必须初始化

	2 局部变量不能用static修饰

	3 静态代码块中的变量为局部变量

	4 java采用局部优先的思想；
	  局部变量可以和成员变量相同，使用标识符调用时，优先使用局部变量

---

# 静态块、构造块、执行顺序优先级 #
1. 静态代码块：给类初始化，JVM加载类时执行，仅执行一次。
2. 构造代码块：给所有对象初始化，每一次创建对象时执行（有通用性）
3. 构造函数：给对应的对象初始化（有针对性），随着类的加载而加载进内存，但不执行（区分执行和加载）
4. 执行顺序优先级：【静态块=静态成员变量】>main()>【构造块=普通成员变量>构造方法】
   且前后两个区域，父类优先级>子类优先级

---

# 关键字 #
***Java所有关键字、保留字***
![](/myimages/3java关键字.jpg)

	1 静态方法（包括main方法）中不能有this，因为静态方法属于类而不属于某个对象，this指代当前对象

	2 static不能修饰局部变量，被static修饰的变量称为静态变量，静态变量属于整个类，而局部变量属于方法，只在该方法内有效

	3 声明为static和transient类型的成员数据不能被串行化/序列化。因为static代表类的状态，transient代表对象的临时数据

	4 volatile关键字：用于限定变量只能从内存中读取，保证对于所有线程而言，值都是一致的。但volatile不能保证线程安全。
	  判断：对volatile变量的操作不会造成阻塞 （√）
      对volatile变量的操作是原子性的  （×）
	  不依赖其他锁机制，多线程环境下的计数器可用volatile实现 （×）

	5 判断：This调用语句必须是构造函数中的第一个可执行语句（×）
	  解析：this()（调用无参构造方法）才必须是构造函数中的第一个可执行语句，用this调用语句（即this.）并不需要

	6 为什么super( )和this( )不能同时出现在同一个构造函数中？
	  答：任何的子类都必须要先调用父类的构造函数，
	  而当你采用“显示构造方法调用”即用this(...)调用当前类的其他构造函数时，这个时候父类的构造就在this(...)里面执行了，
	  this(...)里面应该不仅包括当前类的构造，还必须包括父类的构造。

	7 一个类只要实现了Serilizable接口，这个类的所有属性和方法都会自动序列化；
	  这个类的有些属性需要序列化，而其他属性不需要被序列化；
	  其中不需要序列化的属性和方法用 transient关键字标记

	8 final类型的变量一定要初始化，因为final的变量不可更改

	9 判断：引用变量被final修饰之后，不能再指向其他对象，它指向的对象的内容也是不可变的 （×）
	  解析：使用 final 关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的

	10 synchronized很强大，既可以保证可见性，又可以保证原子性，而volatile不能保证原子性

	11 switch case语句
	  （1）在Java7之前，switch只能支持 byte、short、char、int或者其对应的封装类以及Enum类型，不能是float，double和boolean类型。String类型是java7开始支持。
	  （2）在switch语句中，表达式的值不能是null，否则会在运行时抛出NullPointerException。
	  （3）在case字句中也不能使用null，否则会出现编译错误。同时，case字句的值是不能重复的

	12 形参的修饰符
	  对于形式参数只能用final修饰符，其它任何修饰符都会引起编译器错误
	  但是用这个修饰符也有一定的限制，就是在方法中不能对参数做任何修改
	  不过一般情况下，一个方法的形参不用final修饰。只有在特殊情况下——也就是：方法内部类。
	  一个方法内的内部类如果使用了这个方法的参数或者局部变量的话，这个参数或局部变量应该是final

---

# 继承、实现 #
	1 判断：（1）子类可以继承父类的构造函数（×）
			解析：子类不可以继承父类的构造函数，只是调用父类构造函数（系统默认调用父类无参构造函数super();）
	  	 （2）子类可以继承父类中的私有成员变量（√）
			解析：无论父类中的成员变量是私有的、共有的、还是其它类型的，子类都会拥有父类中的这些成员变量。
			但是父类中的私有成员变量，无法在子类中直接访问，必须通过从父类中继承得到的protected、public方法
			（如getter、setter方法）来访问。

	2 先继承，再实现，否则编译报错

	3 判断：优先选用接口，尽量少用抽象类  （√）
	  解析： 继承的耦合性太强，java推荐高内聚低耦合的设计思路，不推荐使用继承

---

# 抽象类、接口 #
1. 抽象类中可以有构造方法，接口中不能有构造方法，也不能实例化接口的对象
2. 抽象类中可以包含静态方法，接口中不能包含静态方法（JDK1.8之前）
3. 抽象类和接口中都可以包含静态成员变量；抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型
4. 抽象类中可以有普通成员变量/成员方法，接口中不能有（JDK1.8之前）
5. JDK1.8之后，接口可以有default、static方法，而不只有抽象方法
6. 判断：抽象类自身可以定义成员而接口不可以（×）
解析：1.8之后接口允许定义default成员变量/方法
7. 接口中可以不声明任何方法和成员变量；
抽象类可以不包含抽象方法，但有抽象方法的类一定要声明为抽象类。
8. 抽象类和接口中方法的默认访问权限：
关于抽象类
JDK 1.8 以前，抽象类的方法默认访问权限为protected
JDK 1.8 时，抽象类的方法默认访问权限变为default
关于接口
JDK 1.8 以前，接口中的方法必须是public的
JDK 1.8 时，接口中的方法可以是public的，也可以是default的

---

# 重载、重写 #
1. 重载：在同一个类中
①方法名相同，参数列表不同
②与方法的返回值无关，与权限修饰符无关

2. 重写：在子父类中
遵循“两同两小一大”的规则：
①两同：方法名相同，形参列表相同
②两小：子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等
③一大：子类方法的访问权限应比父类方法的访问权限更大或相等

3. 子类重写父类方法时，方法的访问权限不能小于原访问权限。在接口中，方法的默认权限是public，那么子类重写后权限只能是public
4. java中可以有多个重载的main方法，只有public static void main(String[] args){}是函数入口

---

# 多态 #
	1 call by value（值传递）不会改变实际参数的数值
	  call by reference（引用传递）不会改变实际参数的地址，但是可以改变实际参数的内容

	2 判断：多态性意味着一个操作在不同的类中可以有不同的实现方式（√）

---

# 内部类 #
1. 局部内部类：定义在一个方法或者一个作用域
和成员内部类的区别在于：局部内部类的访问仅限于方法内或者该作用域内
2. 成员内部类：定义在类中
（1）成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。
（2）成员内部类中的成员与外部类中的成员重名，默认情况下访问的是内部类的成员。
（3）其他外部类访问成员内部类，需要先创建内部类的对象才能访问其中的成员。  //别人访问它
 （4）成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象
3. 匿名内部类：
（1）匿名内部类用得最多，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。
（2）匿名内部类用法与局部内部类不一致，首先从定义上就不一样，匿名类用在任何允许存在表达式的地方，而局部内部类用于在任何允许出现局部变量的地方出现。 匿名类只能使用一次，而局部类则可以在自己的定义域内多次使用。
（3）匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调
4. 静态内部类：
（1）静态内部类是不需要依赖于外部类的，相当于另外一个外部类。这点和类的静态成员属性有点类似，并且它不能直接使用外部类的非static成员变量或者方法（需要先创建外部类的对象）//它访问别人


	1 判断：包含在java文件里的公共类必须与文件的名字相同（×）
	  解析：公共的内部类不需要和文件同名

	2 判断
	（1）对于局部内部类，只有在方法的局部变量被标记为final或局部变量是effctively final的，内部类才能使用它们     （√）
	（2）成员内部类位于外部类内部，可以直接调用外部类的所有方法（静态方法和非静态方法）    （√）
	（3）由于匿名内部类只能用在方法内部，所以匿名内部类的用法与局部内部类是一致的  （×）
	（4）静态内部类可以访问外部类的成员变量  （×）
	（5）静态内部类不可以直接访问外围类的非静态数据，而非静态内部类可以直接访问外围类的数据，包括私有数据   （√）

	3 匿名内部类：
	（1）匿名内部类的创建格式为： new 父类构造器（参数列表）|实现接口（）{     //匿名内部类的类体实现  }
	（2）使用匿名内部类时，必须继承一个类或实现一个接口
	（3）匿名内部类由于没有名字，因此不能定义构造函数
	（4）匿名内部类中不能含有静态成员变量和静态方法

---

# 异常 #
	1 判断：在有除法存在的代码处，为了防止分母为零，必须抛出并捕获异常（×）
	  解析：分母为0 为运行时异常，jvm帮我们捕获，无需代码里面显式捕获

	2 判断：在有除法存在的代码处，抛不抛出异常均可     （√）
	  解析：除数为0 等ArithmeticException，是RuntimException的子类。而运行时异常将由运行时系统自动抛出，
	  不需要使用throw语句。Java编译器允许忽略运行时异常，一个方法可以既不捕捉，也不声明抛出运行时异常

	3 FileNotFoundException属于编译时异常，需要处理

	4 判断：catch块和finally块可以同时省略    （×）
	  解析：假如try中有异常抛出，则会去执行catch块，再去执行finally块；假如没有catch块，可以直接执行finally块，
	  方法就以抛出异常的方式结束，而finally后的内容也不会被执行，所以catch 和finally不能同时省略

	5 若catch中的参数类型有父类子类关系，此时应该将父类放在后面，子类放在前面

	6 catch捕获到异常后程序结束

	7 finally{}代码块总是比return先执行（除非finally代码块中也有return语句）

	8 （1）finally是在return后面的表达式运算后执行的（返回值已经确定）
	  （2）finally语句块在 catch语句块中的return语句之前执行
	  （3）确定返回值——>执行finally语句——>执行catch语句块中的return语句
	  （4）如果finally语句块中有return会使程序提前结束，不再返回catch中的return语句的结果

	9 wait()方法要以try/catch包覆，或是掷出InterruptedException才行

---

# 包、权限 #

## 权限 ##
1. 包的权限
（1）default修饰符，可以被同一包中所有类访问
（2）protected修饰符，可以被同一包中所有类访问，被修饰的类也可以作为父类被所有子类访问
2. Java中类与成员的**访问权限**共有四种：public，private，protected，还包括default
（1）对于外部类来说，只有两种修饰，public和默认（default），因为外部类放在包中，只有两种可能，包可见和包不可见。
（2）对于内部类来说，可以有所有的修饰，因为内部类放在外部类中，与成员变量的地位一致，所以有四种可能
3. 类**访问控制符**有三种：public ，private， protected


	1 在子类中不能访问父类的private字段，否则编译不通过

	2 判断：实例方法可直接调用超类的实例方法  （×）
	  解析：实例方法可以调用超类公有实例方法

## 包 ##
1. 常用Java包
 java.awt：包含构成抽象窗口工具集的多个类，用来构建和管理应用程序的图形用户界面
 java.lang：提供java编成语言的程序设计的基础类
 java.io：包含提供多种输出输入功能的类，
 java.net：包含执行与网络有关的类，如URL，SCOKET，SEVERSOCKET，
 java.applet：包含java小应用程序的类
 java.util：包含一些实用性的类


	1 判断：静态内部类不可以直接访问外围类的非静态数据，而非静态内部类可以直接访问外围类的数据，包括私有数据 （√）

	2 有一个源代码，只包含import java.util.* ; 这一个import语句，能访问java/util目录下的所有类，不能访问java/util子目录下的所有类

	3 package语句必须作为源文件的第一条非注释性语句，一个源文件只能指定一个包，只能包含一条package语句

---

# 内存管理 #
1. JDK1.6提供的6种作用于不同年代的垃圾收集器

![](/myimages/3JDK1.6垃圾收集器.jpg)
2. 年轻代的GC 叫 young GC ，有时候也叫  minor GC 。年老代或者永久代的 GC ，叫  full GC ，也叫 major GC 
（1）新生代：1）所有对象创建在新生代的Eden区，当Eden区满后触发新生代的Minor GC，将Eden区和非空闲Survivor区存活的对象复制到另外一个空闲的Survivor区中。2）保证一个Survivor区是空的，新生代Minor GC就是在两个Survivor区之间相互复制存活对象，直到Survivor区满为止。
（2）老年代：当Survivor区也满了之后就通过Minor GC将对象复制到老年代。老年代也满了的话，就将触发Full GC，针对整个堆（包括新生代、老年代、持久代）进行垃圾回收。
（3）持久代：持久代如果满了，将触发Full GC
***一则形象的小故事帮你理解：***
![](/myimages/3内存管理.png)
3. 堆内存：
（1）java的堆内存分为两块:permantspace（持久带） 和 heap space
（2）持久带中主要存放静态类型数据，如Java Class, Method 等， 与垃圾收集器要收集的Java对象关系不大。
（3）heapspace分为年轻带和年老带 。年轻代的垃圾回收叫 Young GC， 年老代的垃圾回收叫 Full GC。
（4）年老代溢出原因： 循环上万次的字符串处理、创建上千万个对象、在一段代码内申请上百M甚至上G的内存
（5） 持久代溢出原因：动态加载了大量Java类而导致溢出


	1 jvm中垃圾回收分为scanvenge gc和full GC，其中full GC触发的条件可能有哪些？
	  答：老年代满、持久代满、System.gc()

	2 String str2=str1.substring(5);
	  //substring()方法实际上是new了对象存在堆中，而不是将返回的字符串存在常量池中，常量池是PermGen的

	3 判断：在Java中，对于不再使用的内存资源，如调用完成的方法，“垃圾回收器”会自动将其释放（×）
	  解析：方法调用时，会创建栈帧在栈中，调用完是程序自动出栈释放，而不是gc释放

	4 方法区和堆是被线程共享的区域；在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。
	  方法区和堆内存是线程共享的；程序计数器、虚拟机栈是线程隔离的

	5 （1）jvm堆分为：新生代（一般是一个Eden区，两个Survivor区），老年代（old区）。常量池属于 PermGen（方法区）
	  （2） java7，字符串常量池从方法区移到堆中。java8 整个常量池从方法区中移除。方法区使用元空间（MetaSpace）实现

	6 两个最基本的jvm的垃圾回收算法：复制算法、标记算法
	  新生代基本采用复制算法，老年代采用标记整理算法，cms采用标记清理

	7 Heap空间（不包括PermGen）保留的字符数为new对象所占的空间。PermGen 中是常量所占的空间

	8 判断：垃圾回收机制保证了JAVA程序不会出现内存溢出   （×）
	  解析：垃圾回收机制只是回收不再使用的JVM内存，如果程序有严重BUG，照样内存溢出







