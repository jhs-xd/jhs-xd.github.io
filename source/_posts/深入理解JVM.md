---
title: 深入理解JVM（一）
copyright: true
categories: 
  - 《深入理解JVM》
tags: 
  - JVM

---
<blockquote class="blockquote-center">The shortest way to do many things is to only one thing at a time.
![](/myimages/9.jpg)<blockquote>

自动内存管理机制

<!-- more -->

---

# 为啥学JVM #
1. 在绝大多数情况下，提升硬件性能无法等比例地提升程序的运作性能和并发能力。
2. 这里面有Java虚拟机的原因：为了达到给所有硬件提供一致的虚拟平台的目的，牺牲了一些与硬件相关的性能特性。
3. 当开发人员了解了JVM的运行原理，才能写出最适合虚拟机运行和自优化的代码。

---

# 相关知识点梳理 #
**1. 自动内存管理机制**
- 内存动态分配
 - 运行时数据区域
 - 内存溢出异常
- 垃圾自动回收
  - 垃圾收集算法
  - 垃圾收集器
  - 内存分配与回收策略 

**2. 虚拟机执行子系统**
-  Class类文件的结构
-  虚拟机类加载机制
 -  类加载的时机和过程
 -  类加载器
-  虚拟机字节码执行引擎

**3. 高效并发**
-  Java内存模型
-  Java线程
-  线程安全与锁优化
 -  线程安全
 -  锁优化

---

# 自动内存管理机制 #

## 内存区域 ##

![](/myimages/9运行时数据区.png)

上图中：
绿色区域——所有线程共享的数据区
黄色区域——线程隔离的数据区

**1. 程序计数器**：当前线程正在执行的字节码指令的地址
		（1）每条线程都有一个独立的程序计数器
		（2）如果线程执行Java方法，则计数器记录的是正在执行的字节码问指令的地址
		（3）如果执行的是Native方法，则计数器值为空（Undefined）
		（4）此区域是唯一一个在Java虚拟机规范中没有滚定任何OutOfMemoryError情况的区域

**2. 虚拟机栈**：描述的是Java方法执行的内存模型。每个方法执行时都会创建一个栈帧（Stack Frame），用于存储局部变量表等...
局部变量表中包括：基本数据类型、对象引用、return Address类型

**3. 堆**：虚拟机启动时创建，唯一目的是存储实例对象（包括数组）
		Java堆是内存管理的主要区域，因此也称“GC堆”

**4. 方法区**：用于存储已被虚拟机加载的类信息、常量、静态变量等...

**5. 常量池**：存放编译期生成的各种字面量和符号引用

## 虚拟机中的对象 ##

### 对象的创建（5步） ###
1. 检查类的符号引用，执行类加载过程
		检查：new指令的参数与是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已经被加载
2. 分配内存
		（1）分配方式：指针碰撞（java堆中的内存是规整的）；空闲列表（java堆中的内存不规整）
		（2）内存区域是否规整由所采用的垃圾收集器是否带有压缩整理功能决定
3. 初始化为零值
4. 设置对象头
5. 执行init()方法，按照程序员的意愿初始化

### 对象的内存布局 ###
1. 对象头
	- 对象自身的运行时数据（哈希码、GC分代年龄、线程持有的锁...）
	- 类型指针
	- 记录数组长度的数据（数组特有）
2. 实例数据部分：对象真正存储的有效信息
3. 对齐填充
		对象的大小必须是8字节的整数倍，所以需要占位符来填充

### 对象的访问定位 ###
Java程序需要通过栈上的引用数据来操作堆上的具体对象，主流的对象的访问方式有两种：句柄访问、直接指针
1. 句柄访问：堆中划分一块内存作为句柄池，栈中存储的是对象的句柄地址
2. 直接指针：栈中存储的直接就是对象地址

## 判断对象是否存活 ##
**1. 引用计数算法**
（1）给对象中添加一个引用计数器，引用一次+1，引用失效-1。则引用计数器为0的对象就是不可能再被使用的
（2）不能解决对象之间互相循环引用的问题

**2. 可达性分析算法**
（1）起始点：一系列GC Roots对象
 - 虚拟机栈中引用的对象
 - 方法区中静态变量引用的对象
 - 方法区中常量引用的对象
 - 本地方法栈中JNI（Native方法）引用的对象

（2）引用链（Reference Chain）：从起始点出发的搜索路径
（3）当一个对象到起始点的没有任何引用链相连，则证明此对象不可用

**3. 引用的概念**
（1）JDK1.2之前，引用定义为：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用
（2）JDK1.2后，java对引用概念进行了扩充，分为：
 -  强引用：永远不回收
 -  软引用：将要溢出才回收，SoftReference类实现
 -  弱引用：必定回收，WeakReference类实现
 -  虚引用：被关联对象被回收时会显示系统通知，PhantomReference类实现

**4. 对象被GC的条件**
![](/myimages/9对象被GC的条件.png)
如上图所示，真正宣告一个队形死亡，至少要经理两次标记过程
 -  第一次判断对象是否与GC Roots相连，不相连则做“筛选标记”
 -  第二次判断对象是否重新关联引用链，关联了则做“复活标记”

关于finallize()方法需要注意：
（1）任何一个对象的finallize()方法都只会被系统自动调用一次
（2）如果对象面临下一次回收，它的finallize()方法不会再执行，对象就无法自救了
（3）不建议使用finallize()方法

## 垃圾收集算法 ##
**1. 标记-清除算法（Mark-Sweep）**
首先标记出需要回收的对象，标记完成后统一回收
**不足：**
 -  效率问题——标记和清除的效率低
 -  空间问题——清除后产生大量不连续的内存碎片

**2. 复制算法（Copying）**
将内存分为较大的一块Eden区和两块较小的Survivor区，每次使用Eden和其中一块Survivor。（HotSpot虚拟机中Eden：Survivor=8:1）
回收时，将Eden和Survivor中还存活的对象一次性复制到另外一块Survivor空间上，清理掉Eden和刚才用过的Survivor空间。

**3. 标记-整理算法（Mark-Compact）**
标记过程和“标记-清理”算法一致，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后清理掉端边界以外的内存。

**4. 分代收集算法**
（1）新生代：复制算法
新生代中，每次垃圾收集时都会有大量的对象死去，只有少量存活
（2）老年代：标记-清理算法、标记-整理算法
老年代中对象存活率高，没有额外空间对它进行分配担保

## 垃圾收集器 ##
**从JDK1.3到JDK1.7，GC的发展历程：**

	JDK1.3：Serial收集器（包括Serial Old）
	Parallel收集器（包括ParNew、JDK1.4：Parallel Scavenge、JDK1.6：Parallel Old）
	JDK1.5：Concurrent Mark Sweep（CMS）——第一款真正意义上的并发（Concurrent）收集器；实现了垃圾收集线程和用户线程基本上同时工作
	JDK1.7：Garbage First（G1）

**1. Serial收集器（新生代）**
（1）单线程
（2）Stop The World：Serial进行垃圾收集时，必须暂停其他所有的工作线程（直到最新G1收集器出现，这个问题也没有完全解决，只是用户线程的暂停时间越来越短了）
（3）JVM在Client模式下的**默认**新生代收集器
（4）优点：简单、高效

**2. ParNew收集器（新生代）**
（1）Serial收集器的多线程版本：使用多个线程进行垃圾收集
（2）JVM在Server模式下**首选**的新生代收集器
（3）除了Serial收集器外，只有ParNew能与CMS收集器配合使用（Parallel Scavenge不能配合CMS）

***区分并发与并行***

	并行（Parallel）：指多条垃圾回收线程并行工作，但此时用户线程仍然处于等待状态
	并发（Concurrent）：指用户线程和垃圾处理线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续执行，而垃圾收集程序运行在另一个CPU上

**3. Parallel Scavenge收集器（新生代）**
（1）其他收集器关注GC时**用户线程的停顿时间**，Parallel Scavenge收集器的目标是达到一个可控的**吞吐量**，因此又称“吞吐量优先”收集器

	吞吐量 = 运行用户代码时间 / （运行用户代码时间+垃圾收集时间）
（2）停顿时间短：适合用户交互式程序
    吞吐量大：适合非交互的运算任务

	停顿时间与吞吐量成反比
（3）Parallel Scavenge收集器有一个开关参数，打开后就可以动态调整细节参数（新生代大小、Eden与Survivor比例、晋升老年代对象大小等），以提供最适合的停顿时间/吞吐量——**GC自适应的调节策略**

**4. Serial Old收集器（老年代）**
（1）单线程，标记-整理算法
（2）主要给Client模式下的JVM使用
（3）Server模式下，与Parallel Scavenge收集器搭配使用，或者作为CMS收集器的备选

**5. Parallel Old收集器（老年代）**
（1）多线程，标记-整理算法
（2）Parallel Old是Parallel Scavenge收集器的老年代版本，一般配合Parallel Scavenge，实现“吞吐量优先”

**6. CMS收集器（老年代）**
（1）目标：获取最短回收停顿时间
（2）第一款真正意义上的**并发（Concurrent）收集器**；实现了垃圾收集线程和用户线程基本上同时工作
（3）标记-清除算法
（4）步骤
 -  初始标记（CMS initial mark）
 -  并发标记（CMS concurrent mark）
 -  重新标记（CMS remark）
 -  并发清除（CMS concurrent sweep）

		初始标记、重新标记两个步骤仍然要“Stop The World”，但这两个阶段的停顿时间很短；
		整个过程中并发标记和并发清除耗时最长，但收集器线程都可以与用户线程一起工作；
		所以，总体来说，CMS收集器的内存回收过程食欲用户线程一起并发执行的。
（5）CMS的优点：并发收集、低停顿时间
缺点：CMS收集器对CPU资源非常敏感；无法处理浮动垃圾；CMS基于“标记-清除”算法，效率低、产生大量碎片空间

**7. G1收集器**

		