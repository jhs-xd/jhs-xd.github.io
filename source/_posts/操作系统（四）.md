---
title: 操作系统（四）
copyright: true
categories: 
  - 《计算机操作系统》
tags: 
  - OS

---
<blockquote class="blockquote-center">Miracles sometimes occur, but one has to work terribly for them. ——C. Weizmann
![](/myimages/15.jpg)<blockquote>

存储器管理

<!-- more -->

---

# 存储器的层次结构 #
存储器至少有三级：最高层是CPU寄存器、中间层为主存、最底层是辅存

![](/myimages/15存储器层次结构.jpg)

1. 可执行存储器：CPU寄存器+主存，操作系统存储管理的范畴

		可执行存储器和辅存的访问机制不同，耗费的时间也不同

2. 存储器管理的内容
操作系统对可执行存储器进行**分配**、**回收**、在各个存储层次间进行**数据移动**

## 主存储器与寄存器 ##
1. 主存储器（内存、主存）
保存进程运行时的程序和数据
由于主存储器的访问速度远低于CPU执行指令的速度，故引入了寄存器和高速缓存
2. 寄存器
访问速度最快，完全能与CPU协调工作

## 高速缓存和磁盘缓存 ##
1. 高速缓存
介于内存和寄存器之间，容量（几十KB到几MB）大于寄存器，访问速度快于内存
2. 磁盘缓存
介于内存和磁盘之间，利用内存空间，来暂存磁盘中读出/写入的信息。
主存可以看成是辅存的高速缓存

---

# 程序的装入和链接 #
1. 用户程序要运行，必须要为之创建进程（分配内存资源、申请并初始化PCB）
**创建进程的第一步，将程序和数据装入内存**
2. 对用户程序的处理步骤
（1）编译：编译程序将用户代码编译成若干个**目标模块**
（2）链接：链接程序将一组目标模块和所需要的库函数链接在一起，形成一个完整的**装入模块**
（3）装入：装入程序将**装入模块装入内存**

---

# 连续分配方式 #
连续分配方式：一个用户程序分配一个连续的内存空间
分类：单一连续分配、固定分区分配、动态分区分配、动态重定位分区分配

## 单一连续分配 ##

- 只能用于单用户、单任务的OS中
- 软件简单，硬件要求低，无需采取存储保护措施

## 固定分区分配 ##

-  将内存空间划分为若干个固定大小的区域，每个分区只装入一个进程
-  将分区按大小排队，建立一张分区使用表
-  用于60年代的IBM360的MFT操作系统

## 动态分区分配 ##

-  根据进程的实际需要，动态地为之分配内存空间
-  数据结构：空闲分区表、空闲分区链
-  动态分区分配算法：首次适应算法、循环首次适应算法、最佳适应算法、最坏适应算法、快速适应算法
-  分区分配操作：分配内存、回收内存

## 对换 ##
对换：把内存中暂时不能运行的进程或者暂时不用的程序和数据调出到外存上，腾出内存空间，再把已具备运行条件的进程或所需要的程序和数据调入内存

---

# 基本分页存储管理方式 #
离散分配内存方式：允许将一个进程分散装入到不相邻的分区中（提高内存利用率）
分类：按离散分配的基本单位，分为分页存储管理方式、分段存储管理方式

1. 分页存储管理
（1）将一个进程的逻辑地址空间分成若干个大小相等的片，称为**页**
（2）相应地，把内存空间分成与页面大小相同的若干个存储快，称为**（物理）块**
（3）为进程分配内存时，以块为单位将进程的若干个页分别装入不相邻的物理块中
2. 页表
系统为每个进程建立了一张页面映像表，用于找到每个页面对应的物理块（**页表实现从页号到块号的地址映射**）
![](/myimages/15页表.png)

3. 地址变换机构
（1）作用：将逻辑地址中的页号，转换为内存中的物理块号
（2）地址变换依靠页表实现：一个页表对应一个地址变换寄存器，实际中寄存器被唯一的一个**页表寄存器PTR**替代
（3）运行时，将**页表在内存中的首地址**和**页表长度**保存到页表寄存器
（4）平时，这两个参数存放在本进程的PCB中
4. 多级页表

---

# 基本分段存储管理方式 #

## 基本分段存储管理方式 ##
1. 目的引入分段存储管理方式主要是为了满足用户/程序员在编程和使用上多方面的要求
2. 好处
	-  方便编程
	-  信息共享
	-  信息保护
	-  动态增长
	-  动态链接
3. 分段
（1）进程的内存空间被划分为若干个段，每个段定义了一组逻辑信息
（2）段的逻辑地址（二维）：段号+段内地址
（3）分段的实现：编译程序自动分段，装入程序装入这些段，并为每个段赋予一个段号
4. 段表
系统为每个进程建立一张段映射表，记录段的首地址和段的长度（段表用于实现从逻辑段到物理内存区的映射）
5. 段表寄存器：用于实现逻辑段号到物理地址的变换
6. **分段与分页的区别**
		相同点：（1）两者都采用离散分配方式
			   （2）都要通过地址映射机构进行地址变换
		不同点：（1）页是信息的物理单位——为了实现离散分配
				    段是信息的逻辑单位——为了满足用户需求
			   （2）页的大小固定且由系统决定
					段的大小由用户程序决定
			   （3）分页的进程地址空间是一维的，分段的进程地址空间是二维的，标识一个地址需要段号和段内地址
			   （4）分页系统不容易实现共享和动态链接，分段很容易

## 段页式存储管理方式 ##
既具有分段系统的便与实现、分段可共享、可动态连接等优点；
又能像分页系统很好地解决内存的外部碎片问题；
还可为各个分段离散地分配内存
1. 原理
现将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段富裕一个段名
2. 地址结构：段号+段内页号+页内地址
3. 段页式系统获得一条指令/数据的三次访问
第一次访问：内存中的段表，得到页表首地址
第二次访问：内存中的页表，得到指令/数据的物理地址**（页所在的物理块号+页内地址）**
第三次访问：内存中的指令/数据的物理地址，取出数据

---

# 虚拟存储器 #

## 虚拟存储器的引入 ##
之前的存储器管理方式都要求，将一个进程全部装入内存后才能运行
针对进程会很大，或者进程数量很多，就需要扩充内存

	1 虚拟内存的原理：基于局部性原理，进程运行之前，没有必要全部装入内存，仅需将当前要运行的少数页面或段先装入内存，其余部分留在磁盘上。
	这样可以使一个大的进程在较小的内存中运行，从用户角度看，好像实际内存变大了

	2 虚拟内存：是指具有请求调入和置换功能，能从逻辑上对内存加以扩充的一种存储器系统
	  实质：不用完整地将进程装入内存后才运行，先装入并执行进程的一部分段/页

	3 虚拟内存都建立在离散分配的存储管理方式的基础上，因为连续分配方式需要一次性申请足够多的内存空间，就没有意义

## 虚拟存储器的实现方法 ##
1. 分页请求系统
基本分页系统+请求分页功能+页面置换功能
2. 请求分段系统
基本分段系统+请求分段功能+分段置换功能

## 虚拟存储器的特征 ##
-  多次性：进程被分成多次调入内存
-  对换性：进程运行中允许换进、换出
-  虚拟性

---

# 请求分页存储管理方式 #
建立在基本分页基础上，为了支持虚拟存储器而增加了请求调页功能和页面置换功能

## 硬件支持 ##
1. 页表机制
2. 缺页中断机构
3. 地址变换机构

## 内存分配 ##
1. 确定最小物理块数：取决于计算机的硬件结构
2. 物理块的分配策略
（1）固定分配局部置换
为每个进程分配固定数目的物理块
（2）可变分配全局置换（易实现，空闲物理块由OS管理）
先为系统中的每个进程分配一定数目的物理块，OS自身拥有一个空闲物理块队列，缺页时取出物理块分配给该进程
（3）可变分配局部置换
进程缺页率较高或较低时，能由OS对分配的物理块加以调整
3. 物理块分配算法
（1）平均分配
（2）按比例分配
（3）考虑优先权分配

## 调页策略 ##
1. 调入页面的时机（发生缺页请求）
（1）预调页策略
（2）请求调页策略
2. 确定从何处调入页面
		请求分页系统中的外存分为两部分，存放文件的文件区和存放对换页面的对换区。
		对换区使用的是连续分配方式，文件区采用的离散分配的方式。

		（1）系统拥有足够的对换区空间：可以全部从对换区调入所需页面，以提髙调页速度。
		
    	（2）系统缺少足够的对换区空间：凡不会被修改的文件都直接从文件区调入；
		但对于那些可能被修改的部分，在将它们换出时须调到对换区，以后需要时再从对换区调入。

    	（3）UNIX方式：与进程有关的文件都放在文件区，故未运行过的页面，都应从文件区调入。
		曾经运行过但又被换出的页面，由于是被放在对换区，因此下次调入时应从对换区调入。进程请求的共享页面若被其他进程调入内存，则无需再从对换区调入。

3. 页面调入过程
（1）程序要访问的页面不在内存中，向CPU发出缺页中断
（2）保留CPU环境，转入中断处理程序
（3）中断处理程序通过查找页表，在外存中找到该页
（4）若此时内存能容纳新页，则启动磁盘I/O将所缺之页调入内存
（5）若此时内存已满，则先按照某种**置换算法**从内存中选出一页准备换出，再调入缺页

---

# 页面置换算法 #
- 置换算法：选择换出页面的算法
- 置换算法的好坏直接影响到系统的性能
- 好的置换算法，应具有较低的页面更换频率（把较长时间不会用到的页面先换出）
1. 最佳置换算法
理想化的算法，选择以后永不使用的，或是最长时间内不再被访问的页面
2. 先进先出（FIFO）置换算法
实现简单，但与进程实际运行的规律不相适应
3. 最近最久未使用（LRU）置换算法
性能较好，实现复杂，需要硬件支持（每页配置一个寄存器或栈）
4. Clock置换算法（LRU近似算法）
（1）为每页设置一位访问位，再将内存中所有页面都通过链接指针链接成一个循环队列
（2）当某页被访问时，其访问位被置1
（3）访问位是0则换出该页；访问位是1则置为0，给该页驻留内存的机会

---

# 请求分段存储管理方式 #

## 硬件支持 ##
1. 段表机制
2. 缺段中断机构
3. 地址变换机构

## 分段的共享与保护 ##
1. 共享段表
2. 共享段的分配与回收
3. 分段保护